# 呈尚策划项目展示桌面应用开发文档

## 📋 项目概述

### 项目名称
呈尚策划项目展示桌面应用

### 项目描述
基于现有Next.js UI原型图，使用Tauri框架开发的专业级桌面应用，集成19个专业工具，服务于运营、美工、销售、人事、客服等不同岗位的工作需求。

### 核心价值
- 🎯 **一站式工具平台**：整合19个专业工具，提供统一的工作入口
- 🚀 **桌面应用体验**：原生桌面性能，离线可用，系统深度集成
- 🎨 **现代化UI设计**：基于shadcn/ui的精美界面，毛玻璃效果和流畅动画
- 📊 **数据驱动决策**：实时统计和分析功能，支持业务决策

## 🏗️ 技术架构

### 前端技术栈
```
Frontend (Tauri WebUI)
├── React 18 - 前端UI框架 (支持Server Components)
├── TypeScript - 类型安全开发
├── Next.js 15 (App Router) - 全栈框架适配Tauri
├── Tailwind CSS - 原子化CSS框架
├── shadcn/ui - 高质量组件库
├── Lucide React - 现代化图标库
└── 特殊样式特性
    ├── backdrop-blur - 毛玻璃效果
    ├── gradient backgrounds - 渐变背景
    ├── multi-layer shadows - 多层次阴影
    └── smooth animations - 流畅动画过渡
```

### 桌面应用技术栈
```
Desktop Application
├── Tauri 2.x - 桌面应用框架
├── Rust - 后端核心逻辑
├── WebView2 - 前端渲染引擎
└── 系统集成功能
    ├── 文件系统访问
    ├── 系统通知
    ├── 应用窗口管理
    └── 系统托盘集成
```

## 📱 功能模块架构

### 核心功能分类

#### 1. 运营专用工具模块 (10个工具)
```mermaid
graph TD
    A[运营工具模块] --> B[商家回复解答手册]
    A --> C[外卖运营知识学习系统]
    A --> D[外卖店铺完整运营流程]
    A --> E[外卖外卖运营知识SVG图表集合]
    A --> F[外卖店铺运营数据可视化动画演示系统]
    A --> G[域锦科技AI系统]
    A --> H[微信群发助手]
    A --> I[运营人员每日抽点店铺数统计分析]
    A --> J[呈尚策划运营数据系统]
    A --> K[外卖店铺四件套方案生成系统]
```

#### 2. 美工专用工具模块 (2个工具)
- 外卖闪购产品信息图片采集软件
- 外卖店铺数据处理工具

#### 3. 销售专用工具模块 (2个工具)
- 呈尚策划销售部数据统计系统
- 销售数据报告生成系统

#### 4. 人事专用工具模块 (4个工具)
- 呈尚策划财务记账系统
- 运营部智能排班系统+销售部大扫除安排表系统
- 呈尚策划人事面试顾问系统
- 呈尚策划数据统计系统

#### 5. 客服专用工具模块 (1个工具)
- 外卖店铺信息采集系统

## 🎨 UI/UX 设计规范

### 设计系统
```typescript
// 主色彩方案
const colorScheme = {
  primary: {
    blue: "from-blue-500 to-blue-600",
    purple: "from-purple-500 to-purple-600",
    gradient: "from-blue-600 to-purple-600"
  },
  category: {
    operations: "from-blue-500 to-blue-600",    // 运营工具
    design: "from-purple-500 to-purple-600",    // 美工工具
    sales: "from-green-500 to-green-600",       // 销售工具
    hr: "from-orange-500 to-orange-600",        // 人事工具
    service: "from-pink-500 to-pink-600"        // 客服工具
  },
  background: {
    main: "bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-50/50",
    card: "bg-white/80 backdrop-blur-sm",
    overlay: "bg-white/95 backdrop-blur-md"
  }
}
```

### 组件规范
- **卡片组件**：圆角2xl，毛玻璃效果，hover动画
- **按钮组件**：渐变背景，阴影效果，点击反馈
- **输入组件**：圆角xl，聚焦状态变化，快捷键提示
- **图标系统**：Lucide React，统一尺寸规范
- **动画效果**：transition-all duration-200/300，scale和shadow变化

## 🗂️ 工具数据结构

### 工具信息数据模型
```typescript
interface Tool {
  id: number;
  name: string;
  description: string;
  category: "运营工具" | "美工工具" | "销售工具" | "人事工具" | "客服工具";
  url: string;
  icon: LucideIcon;
  rating: number;
  downloads: string;
  tags: string[];
  color: string;
  featured: boolean;
  lastUpdated: string;
  toolType: "web" | "desktop" | "integrated";
  integrationConfig?: {
    embedSupport: boolean;
    apiEndpoint?: string;
    authRequired: boolean;
  };
}
```

### 完整工具清单数据
```typescript
const toolsData: Tool[] = [
  {
    id: 1,
    name: "商家回复解答手册",
    description: "提供标准化的客户反馈处理模板和沟通技巧",
    category: "运营工具",
    url: "https://xuxikai886.github.io/shangjiahuizong/",
    icon: MessageSquare,
    rating: 4.8,
    downloads: "2.1k",
    tags: ["回复模板", "沟通技巧", "客户反馈"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "2天前",
    toolType: "web"
  },
  {
    id: 2,
    name: "外卖运营知识学习系统",
    description: "系统化的运营知识学习和考试平台",
    category: "运营工具",
    url: "https://xuxikai886.github.io/kaoshixitong/index.html",
    icon: BookOpen,
    rating: 4.7,
    downloads: "1.8k",
    tags: ["知识库", "在线考试", "学习追踪"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "3天前",
    toolType: "web"
  },
  {
    id: 3,
    name: "外卖店铺完整运营流程",
    description: "详细的店铺运营流程指南和操作手册",
    category: "运营工具",
    url: "https://xuxikai886.github.io/meituanyunyingliucheng/",
    icon: Workflow,
    rating: 4.9,
    downloads: "2.5k",
    tags: ["流程可视化", "操作手册", "最佳实践"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "1天前",
    toolType: "web"
  },
  {
    id: 4,
    name: "外卖外卖运营知识SVG图表集合",
    description: "运营知识的可视化图表展示",
    category: "运营工具",
    url: "https://xuxikai886.github.io/meituan-svg-guide-new/",
    icon: BarChart3,
    rating: 4.6,
    downloads: "1.3k",
    tags: ["SVG图表", "交互展示", "知识关联"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "4天前",
    toolType: "web"
  },
  {
    id: 5,
    name: "外卖店铺运营数据可视化动画演示系统",
    description: "动态展示店铺运营数据和趋势分析",
    category: "运营工具",
    url: "https://xuxikai886.github.io/meituanshujuyanshi/",
    icon: TrendingUp,
    rating: 4.8,
    downloads: "2.2k",
    tags: ["数据可视化", "趋势分析", "动画演示"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "2天前",
    toolType: "web"
  },
  {
    id: 6,
    name: "域锦科技AI系统",
    description: "基于AI技术的智能助手平台",
    category: "运营工具",
    url: "https://www.yujinkeji.me",
    icon: Bot,
    rating: 4.9,
    downloads: "3.1k",
    tags: ["AI助手", "智能问答", "思维导图"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "1天前",
    toolType: "web"
  },
  {
    id: 7,
    name: "微信群发助手",
    description: "批量发送微信消息的桌面应用",
    category: "运营工具",
    url: "https://xuxikai886.github.io/weixin/",
    icon: MessageCircle,
    rating: 4.5,
    downloads: "1.9k",
    tags: ["批量发送", "安全可靠", "模拟操作"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "5天前",
    toolType: "desktop"
  },
  {
    id: 8,
    name: "运营人员每日抽点店铺数统计分析",
    description: "运营人员工作量统计和绩效分析",
    category: "运营工具",
    url: "https://xuxikai886.github.io/yunyingshujutongji/",
    icon: Target,
    rating: 4.7,
    downloads: "1.6k",
    tags: ["工作量追踪", "趋势对比", "绩效评估"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "3天前",
    toolType: "web"
  },
  {
    id: 9,
    name: "呈尚策划运营数据系统",
    description: "综合运营数据管理和分析系统",
    category: "运营工具",
    url: "https://xuxikai886.github.io/feishudianputongji/",
    icon: Database,
    rating: 4.8,
    downloads: "2.4k",
    tags: ["数据统计", "解约查询", "运营分析"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "2天前",
    toolType: "web"
  },
  {
    id: 10,
    name: "外卖店铺四件套方案生成系统",
    description: "基于AI的店铺运营方案自动生成",
    category: "运营工具",
    url: "https://xuxikai886.github.io/sijiantaofanganshengcheng/",
    icon: Sparkles,
    rating: 4.9,
    downloads: "2.8k",
    tags: ["AI智能分析", "品牌定位", "商圈调研"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "1天前",
    toolType: "web"
  },
  // 美工工具
  {
    id: 11,
    name: "外卖闪购产品信息图片采集软件",
    description: "自动采集产品信息和图片资源",
    category: "美工工具",
    url: "https://xuxikai886.github.io/shangou-caiji/",
    icon: ImageIcon,
    rating: 4.6,
    downloads: "1.4k",
    tags: ["批量采集", "图片处理", "数据导出"],
    color: "from-purple-500 to-purple-600",
    featured: false,
    lastUpdated: "4天前",
    toolType: "web"
  },
  {
    id: 12,
    name: "外卖店铺数据处理工具",
    description: "店铺图片和产品数据的批量处理",
    category: "美工工具",
    url: "https://xuxikai886.github.io/meituanshangpingtupianxiazai/",
    icon: Edit,
    rating: 4.7,
    downloads: "1.7k",
    tags: ["数据提取", "图片优化", "Fluent设计"],
    color: "from-purple-500 to-purple-600",
    featured: false,
    lastUpdated: "3天前",
    toolType: "web"
  },
  // 销售工具
  {
    id: 13,
    name: "呈尚策划销售部数据统计系统",
    description: "销售数据实时统计和分析",
    category: "销售工具",
    url: "https://www.chengshangcehua.top/",
    icon: ShoppingCart,
    rating: 4.8,
    downloads: "2.3k",
    tags: ["实时数据", "目标追踪", "绩效分析"],
    color: "from-green-500 to-green-600",
    featured: true,
    lastUpdated: "1天前",
    toolType: "web"
  },
  {
    id: 14,
    name: "销售数据报告生成系统",
    description: "20秒快速生成专业销售报告",
    category: "销售工具",
    url: "https://xuxikai886.github.io/xiaoshoushujubaogao/",
    icon: FileText,
    rating: 4.9,
    downloads: "2.6k",
    tags: ["一键生成", "专业模板", "快速导出"],
    color: "from-green-500 to-green-600",
    featured: true,
    lastUpdated: "2天前",
    toolType: "web"
  },
  // 人事工具
  {
    id: 15,
    name: "呈尚策划财务记账系统",
    description: "企业财务收支记录和统计",
    category: "人事工具",
    url: "https://www.yujinkeji.net/login",
    icon: Calculator,
    rating: 4.7,
    downloads: "1.8k",
    tags: ["收支记录", "凭证管理", "财务报表"],
    color: "from-orange-500 to-orange-600",
    featured: false,
    lastUpdated: "3天前",
    toolType: "web"
  },
  {
    id: 16,
    name: "运营部智能排班系统+销售部大扫除安排表系统",
    description: "智能排班和任务分配系统",
    category: "人事工具",
    url: "https://xuxikai886.github.io/cschpaibanxitong/index.html",
    icon: Calendar,
    rating: 4.6,
    downloads: "1.5k",
    tags: ["随机排班", "公平分配", "任务管理"],
    color: "from-orange-500 to-orange-600",
    featured: false,
    lastUpdated: "4天前",
    toolType: "web"
  },
  {
    id: 17,
    name: "呈尚策划人事面试顾问系统",
    description: "简历分析和面试指南生成",
    category: "人事工具",
    url: "https://xuxikai886.github.io/renshimianshixitong/",
    icon: UserCheck,
    rating: 4.8,
    downloads: "2.1k",
    tags: ["简历解析", "面试题库", "评估报告"],
    color: "from-orange-500 to-orange-600",
    featured: true,
    lastUpdated: "2天前",
    toolType: "web"
  },
  {
    id: 18,
    name: "呈尚策划数据统计系统",
    description: "企业综合数据统计和分析",
    category: "人事工具",
    url: "https://xuxikai886.github.io/chengshangcehshujutongji/",
    icon: PieChart,
    rating: 4.7,
    downloads: "1.9k",
    tags: ["多维度统计", "趋势分析", "报表生成"],
    color: "from-orange-500 to-orange-600",
    featured: false,
    lastUpdated: "3天前",
    toolType: "web"
  },
  // 客服工具
  {
    id: 19,
    name: "外卖店铺信息采集系统",
    description: "批量采集外卖店铺基础信息",
    category: "客服工具",
    url: "https://xuxikai886.github.io/meituandianpuxinxicaiji/",
    icon: Search,
    rating: 4.9,
    downloads: "3.2k",
    tags: ["自动解析", "批量处理", "Excel导出"],
    color: "from-pink-500 to-pink-600",
    featured: true,
    lastUpdated: "1天前",
    toolType: "web"
  }
];
```

## 🔧 技术实施方案

### 1. Tauri应用初始化
```bash
# 创建Tauri项目
npm create tauri-app@latest
cd tauri-app

# 配置Tauri
# 修改 src-tauri/tauri.conf.json
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devPath": "http://localhost:3000",
    "distDir": "../out"
  },
  "package": {
    "productName": "呈尚策划项目展示",
    "version": "1.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      },
      "window": {
        "all": false,
        "close": true,
        "hide": true,
        "show": true,
        "maximize": true,
        "minimize": true,
        "unmaximize": true,
        "unminimize": true,
        "startDragging": true
      }
    }
  }
}
```

### 2. Next.js适配Tauri配置
```javascript
// next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  trailingSlash: true,
  images: {
    unoptimized: true
  },
  assetPrefix: process.env.NODE_ENV === 'production' ? './' : undefined,
}

export default nextConfig
```

### 3. 工具集成策略

#### Web工具集成方式
```typescript
// utils/toolLauncher.ts
import { open } from '@tauri-apps/api/shell';

export class ToolLauncher {
  static async openWebTool(url: string) {
    try {
      await open(url);
    } catch (error) {
      console.error('Failed to open tool:', error);
      // 降级到内置webview
      this.openInternalWebview(url);
    }
  }

  static openInternalWebview(url: string) {
    // 在应用内部打开webview
    // 实现工具的嵌入式展示
  }
}
```

#### 桌面工具集成方式
```typescript
// 对于需要桌面集成的工具（如微信群发助手）
// 通过Rust后端实现核心功能
#[tauri::command]
async fn send_wechat_messages(messages: Vec<String>) -> Result<String, String> {
    // Rust实现微信群发逻辑
    Ok("Messages sent successfully".to_string())
}
```

### 4. 数据管理方案

#### 本地数据存储
```typescript
// utils/storage.ts
import { Store } from '@tauri-apps/plugin-store';

export class DataManager {
  private store: Store;

  constructor() {
    this.store = new Store('.settings.dat');
  }

  async saveUserPreferences(preferences: UserPreferences) {
    await this.store.set('user_preferences', preferences);
    await this.store.save();
  }

  async getToolUsageStats(): Promise<ToolUsageStats> {
    return await this.store.get('usage_stats') || {};
  }

  async updateToolUsage(toolId: number) {
    const stats = await this.getToolUsageStats();
    stats[toolId] = (stats[toolId] || 0) + 1;
    await this.store.set('usage_stats', stats);
    await this.store.save();
  }
}
```

### 5. 系统集成功能

#### 系统托盘集成
```rust
// src-tauri/src/main.rs
use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu, SystemTrayEvent};

fn main() {
    let quit = CustomMenuItem::new("quit".to_string(), "退出");
    let show = CustomMenuItem::new("show".to_string(), "显示窗口");
    let tray_menu = SystemTrayMenu::new()
        .add_item(show)
        .add_native_item(SystemTrayMenuItem::Separator)
        .add_item(quit);

    let system_tray = SystemTray::new().with_menu(tray_menu);

    tauri::Builder::default()
        .system_tray(system_tray)
        .on_system_tray_event(|app, event| match event {
            SystemTrayEvent::LeftClick { .. } => {
                let window = app.get_window("main").unwrap();
                window.show().unwrap();
                window.set_focus().unwrap();
            }
            SystemTrayEvent::MenuItemClick { id, .. } => {
                match id.as_str() {
                    "quit" => std::process::exit(0),
                    "show" => {
                        let window = app.get_window("main").unwrap();
                        window.show().unwrap();
                    }
                    _ => {}
                }
            }
            _ => {}
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

## 📊 开发实施计划

### 阶段一：基础架构搭建 (第1-2周)
- [x] 分析现有UI原型图代码
- [ ] 搭建Tauri项目基础架构
- [ ] 配置Next.js适配Tauri的构建流程
- [ ] 迁移现有UI组件到Tauri环境
- [ ] 实现基础窗口管理功能

### 阶段二：核心功能开发 (第3-5周)
- [ ] 实现工具分类和展示功能
- [ ] 开发工具启动和管理机制
- [ ] 集成19个工具的基础访问功能
- [ ] 实现数据统计和使用分析
- [ ] 开发用户偏好设置功能

### 阶段三：高级功能实现 (第6-7周)
- [ ] 实现系统托盘集成
- [ ] 开发离线功能支持
- [ ] 实现工具收藏和最近使用功能
- [ ] 集成系统通知功能
- [ ] 开发快捷键支持

### 阶段四：优化和测试 (第8周)
- [ ] 性能优化和内存管理
- [ ] 跨平台兼容性测试
- [ ] 用户体验优化
- [ ] 安全性检查和加固
- [ ] 自动更新机制实现

## 📁 项目文件结构

```
呈尚策划桌面应用/
├── src-tauri/                 # Tauri后端代码
│   ├── src/
│   │   ├── main.rs           # 主程序入口
│   │   ├── commands.rs       # Tauri命令实现
│   │   └── utils.rs          # 工具函数
│   ├── Cargo.toml            # Rust依赖配置
│   └── tauri.conf.json       # Tauri配置文件
├── app/                      # Next.js应用目录
│   ├── layout.tsx            # 根布局组件
│   ├── page.tsx              # 主页面组件
│   └── globals.css           # 全局样式
├── components/               # React组件目录
│   ├── ui/                   # shadcn/ui组件
│   ├── header.tsx            # 头部组件
│   ├── sidebar.tsx           # 侧边栏组件
│   ├── tool-grid.tsx         # 工具网格组件
│   ├── stats-cards.tsx       # 统计卡片组件
│   └── tool-launcher.tsx     # 工具启动组件
├── lib/                      # 工具库目录
│   ├── utils.ts              # 通用工具函数
│   ├── tool-data.ts          # 工具数据配置
│   └── storage.ts            # 数据存储管理
├── hooks/                    # React Hooks
│   ├── use-tools.ts          # 工具管理Hook
│   └── use-storage.ts        # 存储管理Hook
├── types/                    # TypeScript类型定义
│   └── tools.ts              # 工具相关类型
└── public/                   # 静态资源
    ├── icons/                # 应用图标
    └── assets/               # 其他静态资源
```

## 🔐 安全性考虑

### 数据安全
- 本地数据加密存储
- 用户敏感信息保护
- 安全的外部工具访问机制

### 应用安全
- CSP内容安全策略配置
- 外部链接安全验证
- 恶意代码防护机制

### 更新安全
- 数字签名验证
- 安全的自动更新机制
- 版本回滚保护

## 📈 性能优化策略

### 前端优化
- React组件懒加载
- 图片资源优化
- CSS样式优化
- 动画性能优化

### 后端优化
- Rust代码性能优化
- 内存使用优化
- 文件系统访问优化
- 并发处理优化

### 应用优化
- 启动时间优化
- 窗口渲染优化
- 资源预加载策略
- 缓存机制实现

## 🚀 部署和分发

### 构建配置
```bash
# 开发环境运行
npm run tauri dev

# 生产环境构建
npm run tauri build
```

### 分发策略
- Windows: .msi安装包
- macOS: .dmg磁盘映像
- Linux: .deb/.rpm包
- 自动更新服务器配置

## 📚 开发规范

### 代码规范
- TypeScript严格模式
- ESLint代码检查
- Prettier代码格式化
- Git提交规范

### 组件开发规范
- 遵循shadcn/ui设计系统
- 响应式设计适配
- 无障碍性支持
- 性能监控集成

### 测试策略
- 单元测试覆盖
- 集成测试验证
- 端到端测试保障
- 性能测试监控

## 📞 技术支持和维护

### 版本管理
- 语义化版本控制
- 变更日志维护
- 兼容性保证策略

### 用户反馈
- 错误报告收集
- 用户使用分析
- 功能请求管理
- 技术支持体系

---

## 🎯 项目成功标准

1. **功能完整性**：19个工具全部集成并正常工作
2. **用户体验**：流畅的界面交互和直观的操作流程
3. **性能表现**：快速启动、低内存占用、稳定运行
4. **跨平台兼容**：Windows、macOS、Linux三平台支持
5. **安全可靠**：数据安全保护和稳定的系统集成

---

## 🔄 升级版系统架构设计

### 新增核心功能模块

#### 1. 用户认证与权限管理系统
```mermaid
graph TB
    A[用户登录] --> B[JWT认证服务]
    B --> C[双令牌机制]
    C --> D[Access Token<br/>15分钟有效期]
    C --> E[Refresh Token<br/>7天有效期]
    B --> F[权限验证中间件]
    F --> G[角色权限控制]
    G --> H[功能模块访问控制]
    
    I[MongoDB用户数据库] --> J[用户信息存储]
    I --> K[会话管理]
    I --> L[操作日志记录]
```

#### 2. 实时监控与数据分析系统
```mermaid
graph TB
    A[前端埋点数据收集] --> B[WebSocket实时通信]
    B --> C[数据预处理服务]
    C --> D[MongoDB数据存储]
    D --> E[数据聚合分析]
    E --> F[实时仪表板]
    E --> G[统计报表生成]
    
    H[系统性能监控] --> I[CPU/内存/网络]
    I --> J[告警机制]
    J --> K[管理员通知]
```

### 技术架构升级方案

#### 后端技术栈升级
```toml
# src-tauri/Cargo.toml 新增依赖
[dependencies]
# 核心框架
tauri = { version = "2.0", features = ["api-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }

# 认证与安全
jsonwebtoken = "9.2.0"
argon2 = "0.5.3"
uuid = { version = "1.6.1", features = ["v4"] }
chrono = { version = "0.4.31", features = ["serde"] }

# 数据库集成
mongodb = "2.8.2"
bson = "2.9.0"

# 网络通信
reqwest = { version = "0.12.5", features = ["json", "rustls-tls"] }
tungstenite = "0.21.0"
tokio-tungstenite = "0.21.0"

# 加密与压缩
aes-gcm = "0.10.3"
base64 = "0.22.1"
flate2 = "1.0.28"

# 日志与错误处理
tracing = "0.1.40"
tracing-subscriber = "0.3.18"
anyhow = "1.0.79"
thiserror = "1.0.56"

# 配置管理
config = "0.14.0"
```

## 🗄️ 数据库设计与架构

### MongoDB 集合设计

#### 用户管理集合
```javascript
// users 集合
{
  _id: ObjectId,
  username: String,        // 用户名（唯一）
  email: String,           // 邮箱（唯一）
  password_hash: String,   // Argon2哈希密码
  role: String,            // 用户角色: admin, operator, viewer
  permissions: [String],   // 权限列表
  profile: {
    display_name: String,
    avatar_url: String,
    department: String,    // 部门：运营、美工、销售、人事、客服
    position: String
  },
  settings: {
    theme: String,         // 主题偏好
    language: String,      // 语言设置
    notifications: Boolean
  },
  status: String,          // active, inactive, suspended
  last_login: Date,
  created_at: Date,
  updated_at: Date
}

// user_sessions 集合
{
  _id: ObjectId,
  user_id: ObjectId,
  refresh_token: String,   // 加密存储的刷新令牌
  access_token_jti: String, // JWT ID
  device_info: {
    user_agent: String,
    ip_address: String,
    device_type: String
  },
  expires_at: Date,
  created_at: Date,
  is_revoked: Boolean
}
```

#### 系统监控集合
```javascript
// system_metrics 集合
{
  _id: ObjectId,
  timestamp: Date,
  metrics: {
    cpu_usage: Number,     // CPU使用率
    memory_usage: Number,  // 内存使用率
    disk_usage: Number,    // 磁盘使用率
    network_io: {
      bytes_sent: Number,
      bytes_received: Number
    }
  },
  application_metrics: {
    active_users: Number,
    concurrent_sessions: Number,
    tool_usage_count: Number,
    error_count: Number
  }
}

// user_activities 集合
{
  _id: ObjectId,
  user_id: ObjectId,
  activity_type: String,   // login, logout, tool_access, admin_action
  tool_id: Number,         // 工具ID（如果是工具访问）
  details: {
    tool_name: String,
    duration: Number,      // 使用时长（秒）
    success: Boolean,
    error_message: String
  },
  metadata: {
    ip_address: String,
    user_agent: String,
    session_id: String
  },
  timestamp: Date
}

// audit_logs 集合
{
  _id: ObjectId,
  user_id: ObjectId,
  action: String,          // CREATE, READ, UPDATE, DELETE, LOGIN, LOGOUT
  resource: String,        // 操作的资源类型
  resource_id: String,     // 资源ID
  old_values: Object,      // 修改前的值
  new_values: Object,      // 修改后的值
  ip_address: String,
  user_agent: String,
  success: Boolean,
  error_message: String,
  timestamp: Date
}
```

## 🔐 详细技术实现方案

### Phase 1: Rust 后端服务架构重构

#### 1.1 主应用架构 (src-tauri/src/main.rs)
```rust
use tauri::{generate_context, generate_handler, Builder, Manager, WindowEvent};
use std::sync::Arc;
use tokio::sync::Mutex;

mod config;
mod database;
mod auth;
mod websocket;
mod monitoring;
mod services;
mod utils;
mod error;

use config::AppConfig;
use database::DatabaseService;
use auth::AuthService;
use websocket::WebSocketService;
use monitoring::MonitoringService;

pub struct AppState {
    pub config: Arc<AppConfig>,
    pub db: Arc<DatabaseService>,
    pub auth: Arc<AuthService>,
    pub websocket: Arc<Mutex<WebSocketService>>,
    pub monitoring: Arc<MonitoringService>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 初始化日志系统
    tracing_subscriber::fmt::init();
    
    // 加载配置
    let config = Arc::new(AppConfig::load()?);
    
    // 初始化数据库服务
    let db = Arc::new(DatabaseService::new(&config.database_url).await?);
    
    // 初始化认证服务
    let auth = Arc::new(AuthService::new(config.clone(), db.clone()));
    
    // 初始化WebSocket服务
    let websocket = Arc::new(Mutex::new(WebSocketService::new()));
    
    // 初始化监控服务
    let monitoring = Arc::new(MonitoringService::new(db.clone()));
    
    let app_state = AppState {
        config,
        db,
        auth,
        websocket,
        monitoring,
    };

    Builder::default()
        .manage(app_state)
        .invoke_handler(generate_handler![
            // 认证相关命令
            auth::login,
            auth::logout,
            auth::refresh_token,
            auth::get_current_user,
            
            // 工具管理命令
            services::tools::get_tools,
            services::tools::launch_tool,
            services::tools::track_usage,
            
            // 监控相关命令
            monitoring::get_system_metrics,
            monitoring::get_user_activities,
            monitoring::get_dashboard_data,
            
            // 管理员命令
            services::admin::get_users,
            services::admin::create_user,
            services::admin::update_user,
            services::admin::delete_user,
        ])
        .setup(|app| {
            // 启动后台服务
            let handle = app.handle();
            let state = app.state::<AppState>();
            
            // 启动系统监控
            tokio::spawn(async move {
                let _ = state.monitoring.start_system_monitoring().await;
            });
            
            // 启动WebSocket服务
            tokio::spawn(async move {
                let _ = state.websocket.lock().await.start_server().await;
            });
            
            Ok(())
        })
        .on_window_event(|event| {
            if let WindowEvent::CloseRequested { api, .. } = event.event() {
                // 优雅关闭应用
                api.prevent_close();
                // 执行清理操作
                event.window().hide().unwrap();
            }
        })
        .run(generate_context!())
        .expect("error while running tauri application");
    
    Ok(())
}
```

#### 1.2 配置管理服务 (src-tauri/src/config.rs)
```rust
use serde::{Deserialize, Serialize};
use std::env;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub database_url: String,
    pub jwt_secret: String,
    pub jwt_access_expiry: i64,  // 秒
    pub jwt_refresh_expiry: i64, // 秒
    pub websocket_port: u16,
    pub max_login_attempts: u32,
    pub session_timeout: i64,
    pub encryption_key: String,
    pub log_level: String,
}

impl AppConfig {
    pub fn load() -> Result<Self, config::ConfigError> {
        let mut settings = config::Config::builder();
        
        // 从环境变量加载配置
        settings = settings
            .set_default("database_url", "mongodb://root:6scldk9f@dbconn.sealosbja.site:39056/chengshang_tools?directConnection=true")?
            .set_default("jwt_secret", "your-super-secret-jwt-key-change-this-in-production")?
            .set_default("jwt_access_expiry", 900)?  // 15分钟
            .set_default("jwt_refresh_expiry", 604800)? // 7天
            .set_default("websocket_port", 8080)?
            .set_default("max_login_attempts", 5)?
            .set_default("session_timeout", 3600)? // 1小时
            .set_default("encryption_key", "your-32-byte-encryption-key-here")?
            .set_default("log_level", "info")?;

        // 从环境变量覆盖配置
        if let Ok(db_url) = env::var("DATABASE_URL") {
            settings = settings.set_override("database_url", db_url)?;
        }
        
        if let Ok(jwt_secret) = env::var("JWT_SECRET") {
            settings = settings.set_override("jwt_secret", jwt_secret)?;
        }

        let config = settings.build()?.try_deserialize()?;
        Ok(config)
    }
}
```

#### 1.3 数据库服务实现 (src-tauri/src/database.rs)
```rust
use mongodb::{
    Client, Database, Collection,
    bson::{doc, oid::ObjectId, Document},
    options::{ClientOptions, IndexOptions},
    IndexModel,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use anyhow::Result;

#[derive(Debug, Clone)]
pub struct DatabaseService {
    client: Client,
    database: Database,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct User {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub role: String,
    pub permissions: Vec<String>,
    pub profile: UserProfile,
    pub settings: UserSettings,
    pub status: String,
    pub last_login: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserProfile {
    pub display_name: String,
    pub avatar_url: Option<String>,
    pub department: String,
    pub position: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserSettings {
    pub theme: String,
    pub language: String,
    pub notifications: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserSession {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub user_id: ObjectId,
    pub refresh_token: String,
    pub access_token_jti: String,
    pub device_info: DeviceInfo,
    pub expires_at: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
    pub is_revoked: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DeviceInfo {
    pub user_agent: String,
    pub ip_address: String,
    pub device_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SystemMetrics {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub timestamp: DateTime<Utc>,
    pub metrics: SystemResourceMetrics,
    pub application_metrics: ApplicationMetrics,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SystemResourceMetrics {
    pub cpu_usage: f64,
    pub memory_usage: f64,
    pub disk_usage: f64,
    pub network_io: NetworkMetrics,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkMetrics {
    pub bytes_sent: u64,
    pub bytes_received: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApplicationMetrics {
    pub active_users: u32,
    pub concurrent_sessions: u32,
    pub tool_usage_count: u32,
    pub error_count: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserActivity {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub user_id: ObjectId,
    pub activity_type: String,
    pub tool_id: Option<u32>,
    pub details: ActivityDetails,
    pub metadata: ActivityMetadata,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ActivityDetails {
    pub tool_name: Option<String>,
    pub duration: Option<u32>,
    pub success: bool,
    pub error_message: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ActivityMetadata {
    pub ip_address: String,
    pub user_agent: String,
    pub session_id: String,
}

impl DatabaseService {
    pub async fn new(connection_string: &str) -> Result<Self> {
        let client_options = ClientOptions::parse(connection_string).await?;
        let client = Client::with_options(client_options)?;
        let database = client.database("chengshang_tools");
        
        let service = DatabaseService { client, database };
        
        // 创建索引
        service.create_indexes().await?;
        
        Ok(service)
    }
    
    async fn create_indexes(&self) -> Result<()> {
        // 用户集合索引
        let users_collection: Collection<User> = self.database.collection("users");
        let username_index = IndexModel::builder()
            .keys(doc! { "username": 1 })
            .options(IndexOptions::builder().unique(true).build())
            .build();
        let email_index = IndexModel::builder()
            .keys(doc! { "email": 1 })
            .options(IndexOptions::builder().unique(true).build())
            .build();
        users_collection.create_indexes(vec![username_index, email_index], None).await?;
        
        // 会话集合索引
        let sessions_collection: Collection<UserSession> = self.database.collection("user_sessions");
        let session_index = IndexModel::builder()
            .keys(doc! { "user_id": 1, "expires_at": 1 })
            .build();
        sessions_collection.create_index(session_index, None).await?;
        
        // 活动日志索引
        let activities_collection: Collection<UserActivity> = self.database.collection("user_activities");
        let activity_index = IndexModel::builder()
            .keys(doc! { "user_id": 1, "timestamp": -1 })
            .build();
        activities_collection.create_index(activity_index, None).await?;
        
        // 系统指标索引
        let metrics_collection: Collection<SystemMetrics> = self.database.collection("system_metrics");
        let metrics_index = IndexModel::builder()
            .keys(doc! { "timestamp": -1 })
            .build();
        metrics_collection.create_index(metrics_index, None).await?;
        
        Ok(())
    }
    
    // 用户管理方法
    pub async fn create_user(&self, user: User) -> Result<ObjectId> {
        let collection: Collection<User> = self.database.collection("users");
        let result = collection.insert_one(user, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn find_user_by_username(&self, username: &str) -> Result<Option<User>> {
        let collection: Collection<User> = self.database.collection("users");
        let filter = doc! { "username": username };
        let user = collection.find_one(Some(filter), None).await?;
        Ok(user)
    }
    
    pub async fn find_user_by_email(&self, email: &str) -> Result<Option<User>> {
        let collection: Collection<User> = self.database.collection("users");
        let filter = doc! { "email": email };
        let user = collection.find_one(Some(filter), None).await?;
        Ok(user)
    }
    
    pub async fn update_user_last_login(&self, user_id: ObjectId) -> Result<()> {
        let collection: Collection<User> = self.database.collection("users");
        let filter = doc! { "_id": user_id };
        let update = doc! {
            "$set": {
                "last_login": Utc::now(),
                "updated_at": Utc::now()
            }
        };
        collection.update_one(filter, update, None).await?;
        Ok(())
    }
    
    // 会话管理方法
    pub async fn create_session(&self, session: UserSession) -> Result<ObjectId> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let result = collection.insert_one(session, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn find_session_by_token(&self, refresh_token: &str) -> Result<Option<UserSession>> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let filter = doc! {
            "refresh_token": refresh_token,
            "is_revoked": false,
            "expires_at": { "$gt": Utc::now() }
        };
        let session = collection.find_one(Some(filter), None).await?;
        Ok(session)
    }
    
    pub async fn revoke_session(&self, session_id: ObjectId) -> Result<()> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let filter = doc! { "_id": session_id };
        let update = doc! { "$set": { "is_revoked": true } };
        collection.update_one(filter, update, None).await?;
        Ok(())
    }
    
    pub async fn cleanup_expired_sessions(&self) -> Result<u64> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let filter = doc! { "expires_at": { "$lt": Utc::now() } };
        let result = collection.delete_many(filter, None).await?;
        Ok(result.deleted_count)
    }
    
    // 活动日志方法
    pub async fn log_user_activity(&self, activity: UserActivity) -> Result<ObjectId> {
        let collection: Collection<UserActivity> = self.database.collection("user_activities");
        let result = collection.insert_one(activity, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn get_user_activities(&self, user_id: ObjectId, limit: i64) -> Result<Vec<UserActivity>> {
        let collection: Collection<UserActivity> = self.database.collection("user_activities");
        let filter = doc! { "user_id": user_id };
        let options = mongodb::options::FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .limit(limit)
            .build();
        
        let mut cursor = collection.find(filter, options).await?;
        let mut activities = Vec::new();
        
        while cursor.advance().await? {
            activities.push(cursor.deserialize_current()?);
        }
        
        Ok(activities)
    }
    
    // 系统指标方法
    pub async fn save_system_metrics(&self, metrics: SystemMetrics) -> Result<ObjectId> {
        let collection: Collection<SystemMetrics> = self.database.collection("system_metrics");
        let result = collection.insert_one(metrics, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn get_recent_metrics(&self, hours: i64) -> Result<Vec<SystemMetrics>> {
        let collection: Collection<SystemMetrics> = self.database.collection("system_metrics");
        let since = Utc::now() - chrono::Duration::hours(hours);
        let filter = doc! { "timestamp": { "$gte": since } };
        let options = mongodb::options::FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .build();
        
        let mut cursor = collection.find(filter, options).await?;
        let mut metrics = Vec::new();
        
        while cursor.advance().await? {
            metrics.push(cursor.deserialize_current()?);
        }
        
        Ok(metrics)
    }
    
    // 数据库健康检查
    pub async fn health_check(&self) -> Result<Document> {
        let admin_db = self.client.database("admin");
        let result = admin_db.run_command(doc! { "ping": 1 }, None).await?;
        Ok(result)
    }
    
    // 获取数据库统计信息
    pub async fn get_database_stats(&self) -> Result<Document> {
        let result = self.database.run_command(doc! { "dbStats": 1 }, None).await?;
        Ok(result)
    }
}
```

#### 1.4 认证服务核心实现 (src-tauri/src/auth.rs)
```rust
use crate::database::{DatabaseService, User, UserSession, DeviceInfo};
use crate::config::AppConfig;
use crate::error::AuthError;

use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
use argon2::password_hash::{rand_core::OsRng, SaltString};
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey, TokenData};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use chrono::{DateTime, Utc, Duration};
use uuid::Uuid;
use std::collections::HashMap;
use tokio::sync::RwLock;

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,      // 用户ID
    pub username: String,
    pub role: String,
    pub permissions: Vec<String>,
    pub exp: i64,         // 过期时间
    pub iat: i64,         // 签发时间
    pub jti: String,      // JWT ID
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
    pub device_info: DeviceInfo,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LoginResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub expires_in: i64,
    pub user: UserInfo,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserInfo {
    pub id: String,
    pub username: String,
    pub email: String,
    pub role: String,
    pub permissions: Vec<String>,
    pub profile: crate::database::UserProfile,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RefreshTokenRequest {
    pub refresh_token: String,
}

pub struct AuthService {
    config: Arc<AppConfig>,
    database: Arc<DatabaseService>,
    login_attempts: Arc<RwLock<HashMap<String, (u32, DateTime<Utc>)>>>,
}

impl AuthService {
    pub fn new(config: Arc<AppConfig>, database: Arc<DatabaseService>) -> Self {
        Self {
            config,
            database,
            login_attempts: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn login(&self, request: LoginRequest) -> Result<LoginResponse, AuthError> {
        // 检查登录频率限制
        self.check_login_rate_limit(&request.username).await?;
        
        // 验证用户凭据
        let user = self.verify_credentials(&request.username, &request.password).await?;
        
        // 生成JWT令牌
        let (access_token, refresh_token) = self.generate_tokens(&user).await?;
        
        // 创建用户会话
        let session = UserSession {
            id: None,
            user_id: user.id.unwrap(),
            refresh_token: refresh_token.clone(),
            access_token_jti: self.extract_jti_from_token(&access_token)?,
            device_info: request.device_info,
            expires_at: Utc::now() + Duration::seconds(self.config.jwt_refresh_expiry),
            created_at: Utc::now(),
            is_revoked: false,
        };
        
        self.database.create_session(session).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        // 更新用户最后登录时间
        self.database.update_user_last_login(user.id.unwrap()).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        // 清除登录尝试记录
        self.clear_login_attempts(&request.username).await;
        
        // 记录登录活动
        self.log_login_activity(&user, &request.device_info, true).await;
        
        Ok(LoginResponse {
            access_token,
            refresh_token,
            expires_in: self.config.jwt_access_expiry,
            user: UserInfo {
                id: user.id.unwrap().to_hex(),
                username: user.username,
                email: user.email,
                role: user.role,
                permissions: user.permissions,
                profile: user.profile,
            },
        })
    }
    
    pub async fn refresh_token(&self, request: RefreshTokenRequest) -> Result<LoginResponse, AuthError> {
        // 验证刷新令牌
        let session = self.database.find_session_by_token(&request.refresh_token).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?
            .ok_or(AuthError::InvalidToken)?;
        
        // 获取用户信息
        let user = self.database.find_user_by_username(&session.user_id.to_hex()).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?
            .ok_or(AuthError::UserNotFound)?;
        
        // 生成新的令牌
        let (access_token, new_refresh_token) = self.generate_tokens(&user).await?;
        
        // 撤销旧的会话
        self.database.revoke_session(session.id.unwrap()).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        // 创建新的会话
        let new_session = UserSession {
            id: None,
            user_id: user.id.unwrap(),
            refresh_token: new_refresh_token.clone(),
            access_token_jti: self.extract_jti_from_token(&access_token)?,
            device_info: session.device_info,
            expires_at: Utc::now() + Duration::seconds(self.config.jwt_refresh_expiry),
            created_at: Utc::now(),
            is_revoked: false,
        };
        
        self.database.create_session(new_session).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        Ok(LoginResponse {
            access_token,
            refresh_token: new_refresh_token,
            expires_in: self.config.jwt_access_expiry,
            user: UserInfo {
                id: user.id.unwrap().to_hex(),
                username: user.username,
                email: user.email,
                role: user.role,
                permissions: user.permissions,
                profile: user.profile,
            },
        })
    }
    
    pub async fn logout(&self, refresh_token: &str) -> Result<(), AuthError> {
        if let Some(session) = self.database.find_session_by_token(refresh_token).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))? {
            self.database.revoke_session(session.id.unwrap()).await
                .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        }
        Ok(())
    }
    
    pub async fn verify_token(&self, token: &str) -> Result<Claims, AuthError> {
        let token_data = decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.config.jwt_secret.as_ref()),
            &Validation::default(),
        ).map_err(|_| AuthError::InvalidToken)?;
        
        Ok(token_data.claims)
    }
    
    async fn verify_credentials(&self, username: &str, password: &str) -> Result<User, AuthError> {
        let user = self.database.find_user_by_username(username).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?
            .ok_or(AuthError::InvalidCredentials)?;
        
        // 验证密码
        let parsed_hash = PasswordHash::new(&user.password_hash)
            .map_err(|_| AuthError::InvalidCredentials)?;
        
        Argon2::default()
            .verify_password(password.as_bytes(), &parsed_hash)
            .map_err(|_| AuthError::InvalidCredentials)?;
        
        // 检查用户状态
        if user.status != "active" {
            return Err(AuthError::UserInactive);
        }
        
        Ok(user)
    }
    
    async fn generate_tokens(&self, user: &User) -> Result<(String, String), AuthError> {
        let now = Utc::now();
        let access_exp = now + Duration::seconds(self.config.jwt_access_expiry);
        let refresh_exp = now + Duration::seconds(self.config.jwt_refresh_expiry);
        
        // 生成访问令牌
        let access_claims = Claims {
            sub: user.id.unwrap().to_hex(),
            username: user.username.clone(),
            role: user.role.clone(),
            permissions: user.permissions.clone(),
            exp: access_exp.timestamp(),
            iat: now.timestamp(),
            jti: Uuid::new_v4().to_string(),
        };
        
        let access_token = encode(
            &Header::default(),
            &access_claims,
            &EncodingKey::from_secret(self.config.jwt_secret.as_ref()),
        ).map_err(|_| AuthError::TokenGenerationFailed)?;
        
        // 生成刷新令牌
        let refresh_claims = Claims {
            sub: user.id.unwrap().to_hex(),
            username: user.username.clone(),
            role: user.role.clone(),
            permissions: user.permissions.clone(),
            exp: refresh_exp.timestamp(),
            iat: now.timestamp(),
            jti: Uuid::new_v4().to_string(),
        };
        
        let refresh_token = encode(
            &Header::default(),
            &refresh_claims,
            &EncodingKey::from_secret(self.config.jwt_secret.as_ref()),
        ).map_err(|_| AuthError::TokenGenerationFailed)?;
        
        Ok((access_token, refresh_token))
    }
    
    async fn check_login_rate_limit(&self, username: &str) -> Result<(), AuthError> {
        let mut attempts = self.login_attempts.write().await;
        let now = Utc::now();
        
        if let Some((count, last_attempt)) = attempts.get(username) {
            // 如果超过最大尝试次数且在锁定时间内
            if *count >= self.config.max_login_attempts
                && now.signed_duration_since(*last_attempt).num_minutes() < 15 {
                return Err(AuthError::TooManyLoginAttempts);
            }
        }
        
        // 记录登录尝试
        let current_count = attempts.get(username).map(|(c, _)| *c).unwrap_or(0);
        attempts.insert(username.to_string(), (current_count + 1, now));
        
        Ok(())
    }
    
    async fn clear_login_attempts(&self, username: &str) {
        let mut attempts = self.login_attempts.write().await;
        attempts.remove(username);
    }
    
    fn extract_jti_from_token(&self, token: &str) -> Result<String, AuthError> {
        let token_data = decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.config.jwt_secret.as_ref()),
            &Validation::default(),
        ).map_err(|_| AuthError::InvalidToken)?;
        
        Ok(token_data.claims.jti)
    }
    
    async fn log_login_activity(&self, user: &User, device_info: &DeviceInfo, success: bool) {
        use crate::database::{UserActivity, ActivityDetails, ActivityMetadata};
        
        let activity = UserActivity {
            id: None,
            user_id: user.id.unwrap(),
            activity_type: if success { "login".to_string() } else { "login_failed".to_string() },
            tool_id: None,
            details: ActivityDetails {
                tool_name: None,
                duration: None,
                success,
                error_message: if success { None } else { Some("Login failed".to_string()) },
            },
            metadata: ActivityMetadata {
                ip_address: device_info.ip_address.clone(),
                user_agent: device_info.user_agent.clone(),
                session_id: Uuid::new_v4().to_string(),
            },
            timestamp: Utc::now(),
        };
        
        let _ = self.database.log_user_activity(activity).await;
    }
    
    pub fn hash_password(password: &str) -> Result<String, AuthError> {
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();
        let password_hash = argon2
            .hash_password(password.as_bytes(), &salt)
            .map_err(|_| AuthError::PasswordHashingFailed)?
            .to_string();
        Ok(password_hash)
    }
}

// Tauri命令实现
#[tauri::command]
pub async fn login(
    state: tauri::State<'_, crate::AppState>,
    request: LoginRequest,
) -> Result<LoginResponse, String> {
    state.auth.login(request).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn logout(
    state: tauri::State<'_, crate::AppState>,
    refresh_token: String,
) -> Result<(), String> {
    state.auth.logout(&refresh_token).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn refresh_token(
    state: tauri::State<'_, crate::AppState>,
    request: RefreshTokenRequest,
) -> Result<LoginResponse, String> {
    state.auth.refresh_token(request).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_current_user(
    state: tauri::State<'_, crate::AppState>,
    access_token: String,
) -> Result<UserInfo, String> {
    let claims = state.auth.verify_token(&access_token).await
        .map_err(|e| e.to_string())?;
    
    let user = state.database.find_user_by_username(&claims.username).await
        .map_err(|e| e.to_string())?
        .ok_or("User not found")?;
    
    Ok(UserInfo {
        id: user.id.unwrap().to_hex(),
        username: user.username,
        email: user.email,
        role: user.role,
        permissions: user.permissions,
        profile: user.profile,
    })
}
```

## Phase 2: 前端React组件实现

### 2.1 登录表单组件 (components/auth/login-form.tsx)
```typescript
'use client'

import { useState } from 'react'
import { motion } from 'framer-motion'
import { Eye, EyeOff, Lock, User, Loader2, AlertCircle } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { invoke } from '@tauri-apps/api/tauri'

export interface LoginFormData {
  username: string
  password: string
  device_info: {
    user_agent: string
    ip_address: string
    device_type: string
  }
}

export interface LoginResponse {
  access_token: string
  refresh_token: string
  expires_in: number
  user: {
    id: string
    username: string
    email: string
    role: string
    permissions: string[]
    profile: {
      display_name: string
      avatar_url?: string
      department: string
      position: string
    }
  }
}

export function LoginForm() {
  const [formData, setFormData] = useState({
    username: '',
    password: ''
  })
  const [showPassword, setShowPassword] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    try {
      // 获取设备信息
      const deviceInfo = {
        user_agent: navigator.userAgent,
        ip_address: '127.0.0.1', // 在实际应用中从API获取
        device_type: 'desktop'
      }

      const loginRequest: LoginFormData = {
        username: formData.username,
        password: formData.password,
        device_info: deviceInfo
      }

      // 调用Tauri后端登录命令
      const response = await invoke<LoginResponse>('login', { request: loginRequest })
      
      // 存储令牌到本地存储
      localStorage.setItem('access_token', response.access_token)
      localStorage.setItem('refresh_token', response.refresh_token)
      localStorage.setItem('user_info', JSON.stringify(response.user))

      // 触发登录成功事件
      window.dispatchEvent(new CustomEvent('auth:login', {
        detail: { user: response.user }
      }))

    } catch (err: any) {
      setError(err.message || '登录失败，请检查用户名和密码')
    } finally {
      setIsLoading(false)
    }
  }

  const inputVariants = {
    focus: { scale: 1.02, transition: { duration: 0.2 } },
    blur: { scale: 1, transition: { duration: 0.2 } }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-50/50 p-4">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="w-full max-w-md"
      >
        <Card className="backdrop-blur-sm bg-white/80 shadow-2xl border-0">
          <CardHeader className="space-y-1 text-center">
            <div className="flex justify-center mb-4">
              <div className="p-3 bg-gradient-to-r from-blue-600 to-purple-600 rounded-full">
                <Lock className="h-6 w-6 text-white" />
              </div>
            </div>
            <CardTitle className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
              呈尚策划工具箱
            </CardTitle>
            <CardDescription className="text-slate-600">
              登录您的账户以访问专业工具
            </CardDescription>
          </CardHeader>
          
          <CardContent>
            <form onSubmit={handleSubmit} className="space-y-4">
              {error && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{ duration: 0.3 }}
                >
                  <Alert variant="destructive" className="bg-red-50/80 border-red-200">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>{error}</AlertDescription>
                  </Alert>
                </motion.div>
              )}

              <div className="space-y-2">
                <Label htmlFor="username" className="text-sm font-medium text-slate-700">
                  用户名
                </Label>
                <motion.div
                  variants={inputVariants}
                  whileFocus="focus"
                  className="relative"
                >
                  <User className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                  <Input
                    id="username"
                    type="text"
                    placeholder="输入用户名"
                    value={formData.username}
                    onChange={(e) => setFormData(prev => ({ ...prev, username: e.target.value }))}
                    className="pl-10 h-11 bg-white/50 border-slate-200 focus:border-blue-400 focus:ring-blue-400/20"
                    required
                    disabled={isLoading}
                  />
                </motion.div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="password" className="text-sm font-medium text-slate-700">
                  密码
                </Label>
                <motion.div
                  variants={inputVariants}
                  whileFocus="focus"
                  className="relative"
                >
                  <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                  <Input
                    id="password"
                    type={showPassword ? 'text' : 'password'}
                    placeholder="输入密码"
                    value={formData.password}
                    onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
                    className="pl-10 pr-10 h-11 bg-white/50 border-slate-200 focus:border-blue-400 focus:ring-blue-400/20"
                    required
                    disabled={isLoading}
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-400 hover:text-slate-600 transition-colors"
                    disabled={isLoading}
                  >
                    {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                  </button>
                </motion.div>
              </div>

              <motion.div
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                className="pt-2"
              >
                <Button
                  type="submit"
                  className="w-full h-11 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-medium shadow-lg hover:shadow-xl transition-all duration-200"
                  disabled={isLoading}
                >
                  {isLoading ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      登录中...
                    </>
                  ) : (
                    '登录'
                  )}
                </Button>
              </motion.div>
            </form>

            <div className="mt-6 text-center text-sm text-slate-600">
              <p>忘记密码？请联系系统管理员</p>
            </div>
          </CardContent>
        </Card>
      </motion.div>
    </div>
  )
}
```

### 2.2 管理后台仪表板组件 (components/admin/dashboard.tsx)
```typescript
'use client'

import { useState, useEffect } from 'react'
import { motion } from 'framer-motion'
import {
  Activity, Users, Server, Database, AlertTriangle,
  TrendingUp, Clock, Shield, BarChart3, Settings
} from 'lucide-react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { invoke } from '@tauri-apps/api/tauri'

interface DashboardData {
  system_metrics: {
    cpu_usage: number
    memory_usage: number
    disk_usage: number
    network_io: {
      bytes_sent: number
      bytes_received: number
    }
  }
  application_metrics: {
    active_users: number
    concurrent_sessions: number
    tool_usage_count: number
    error_count: number
  }
  recent_activities: Array<{
    id: string
    user_id: string
    activity_type: string
    tool_name?: string
    timestamp: string
    success: boolean
  }>
  alerts: Array<{
    id: string
    type: 'warning' | 'error' | 'info'
    message: string
    timestamp: string
  }>
}

export function AdminDashboard() {
  const [dashboardData, setDashboardData] = useState<DashboardData | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null)

  // 获取仪表板数据
  const fetchDashboardData = async () => {
    try {
      const data = await invoke<DashboardData>('get_dashboard_data')
      setDashboardData(data)
      setLastUpdate(new Date())
    } catch (error) {
      console.error('Failed to fetch dashboard data:', error)
    } finally {
      setIsLoading(false)
    }
  }

  // 组件挂载时获取数据，并设置定时刷新
  useEffect(() => {
    fetchDashboardData()

    // 设置WebSocket连接以获取实时更新
    const connectWebSocket = () => {
      const ws = new WebSocket('ws://localhost:8080/dashboard')
      
      ws.onmessage = (event) => {
        const update = JSON.parse(event.data)
        if (update.type === 'dashboard_update') {
          setDashboardData(update.data)
          setLastUpdate(new Date())
        }
      }

      ws.onclose = () => {
        // 重连WebSocket
        setTimeout(connectWebSocket, 5000)
      }

      return ws
    }

    const ws = connectWebSocket()

    // 清理函数
    return () => {
      ws.close()
    }
  }, [])

  if (isLoading || !dashboardData) {
    return (
      <div className="p-6 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          {[...Array(4)].map((_, i) => (
            <Card key={i} className="animate-pulse">
              <CardHeader className="space-y-2">
                <div className="h-4 bg-gray-200 rounded w-3/4"></div>
                <div className="h-8 bg-gray-200 rounded w-1/2"></div>
              </CardHeader>
            </Card>
          ))}
        </div>
      </div>
    )
  }

  const { system_metrics, application_metrics, recent_activities, alerts } = dashboardData

  return (
    <div className="p-6 space-y-6 bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-50/50 min-h-screen">
      {/* 页面标题 */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
            系统管理仪表板
          </h1>
          <p className="text-slate-600 mt-1">
            实时监控系统状态和应用性能
            {lastUpdate && (
              <span className="ml-2 text-sm">
                最后更新: {lastUpdate.toLocaleTimeString()}
              </span>
            )}
          </p>
        </div>
        <Button onClick={fetchDashboardData} variant="outline" size="sm">
          <Activity className="h-4 w-4 mr-2" />
          刷新数据
        </Button>
      </div>

      {/* 告警信息 */}
      {alerts.length > 0 && (
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          className="space-y-2"
        >
          {alerts.slice(0, 3).map((alert) => (
            <Alert key={alert.id} variant={alert.type === 'error' ? 'destructive' : 'default'}>
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>
                {alert.message}
                <span className="ml-2 text-xs opacity-70">
                  {new Date(alert.timestamp).toLocaleString()}
                </span>
              </AlertDescription>
            </Alert>
          ))}
        </motion.div>
      )}

      {/* 核心指标卡片 */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.1 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">活跃用户</CardTitle>
              <Users className="h-4 w-4 text-blue-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {application_metrics.active_users}
              </div>
              <p className="text-xs text-slate-600 mt-1">
                当前在线用户数量
              </p>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.2 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">工具使用</CardTitle>
              <BarChart3 className="h-4 w-4 text-green-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {application_metrics.tool_usage_count}
              </div>
              <p className="text-xs text-slate-600 mt-1">
                今日工具访问次数
              </p>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.3 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">系统负载</CardTitle>
              <Server className="h-4 w-4 text-orange-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {system_metrics.cpu_usage.toFixed(1)}%
              </div>
              <p className="text-xs text-slate-600 mt-1">
                CPU使用率
              </p>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.4 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">错误数量</CardTitle>
              <AlertTriangle className="h-4 w-4 text-red-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {application_metrics.error_count}
              </div>
              <p className="text-xs text-slate-600 mt-1">
                今日错误报告
              </p>
            </CardContent>
          </Card>
        </motion.div>
      </div>

      {/* 详细监控数据 */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* 系统资源监控 */}
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.5 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg">
            <CardHeader>
              <CardTitle className="flex items-center">
                <Server className="h-5 w-5 mr-2 text-blue-600" />
                系统资源监控
              </CardTitle>
              <CardDescription>实时系统性能指标</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-slate-600">CPU使用率</span>
                  <span className="text-sm font-medium">{system_metrics.cpu_usage.toFixed(1)}%</span>
                </div>
                <Progress value={system_metrics.cpu_usage} className="h-2" />
              </div>

              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-slate-600">内存使用率</span>
                  <span className="text-sm font-medium">{system_metrics.memory_usage.toFixed(1)}%</span>
                </div>
                <Progress value={system_metrics.memory_usage} className="h-2" />
              </div>

              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-slate-600">磁盘使用率</span>
                  <span className="text-sm font-medium">{system_metrics.disk_usage.toFixed(1)}%</span>
                </div>
                <Progress value={system_metrics.disk_usage} className="h-2" />
              </div>

              <div className="pt-2 border-t">
                <div className="flex justify-between text-sm">
                  <span className="text-slate-600">网络发送</span>
                  <span className="font-medium">
                    {(system_metrics.network_io.bytes_sent / 1024 / 1024).toFixed(2)} MB
                  </span>
                </div>
                <div className="flex justify-between text-sm mt-1">
                  <span className="text-slate-600">网络接收</span>
                  <span className="font-medium">
                    {(system_metrics.network_io.bytes_received / 1024 / 1024).toFixed(2)} MB
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>
        </motion.div>

        {/* 用户活动日志 */}
        <motion.div
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.6 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg">
            <CardHeader>
              <CardTitle className="flex items-center">
                <Activity className="h-5 w-5 mr-2 text-green-600" />
                最近活动
              </CardTitle>
              <CardDescription>用户操作日志记录</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-3 max-h-80 overflow-y-auto">
                {recent_activities.map((activity) => (
                  <div key={activity.id} className="flex items-center justify-between p-3 bg-slate-50/50 rounded-lg">
                    <div className="flex items-center space-x-3">
                      <div className={`w-2 h-2 rounded-full ${
                        activity.success ? 'bg-green-500' : 'bg-red-500'
                      }`} />
                      <div>
                        <p className="text-sm font-medium text-slate-900">
                          {activity.activity_type === 'login' ? '用户登录' :
                           activity.activity_type === 'tool_access' ? `使用工具: ${activity.tool_name}` :
                           activity.activity_type}
                        </p>
                        <p className="text-xs text-slate-500">
                          {new Date(activity.timestamp).toLocaleString()}
                        </p>
                      </div>
                    </div>
                    <Badge variant={activity.success ? "default" : "destructive"} className="text-xs">
                      {activity.success ? '成功' : '失败'}
                    </Badge>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </motion.div>
      </div>
    </div>
  )
}
```

### 2.3 WebSocket实时通信服务 (src-tauri/src/websocket.rs)
```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, mpsc};
use tokio_tungstenite::{accept_async, WebSocketStream};
use tokio::net::{TcpListener, TcpStream};
use tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use tracing::{info, error, warn};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebSocketMessage {
    pub message_type: String,
    pub data: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug)]
pub struct WebSocketClient {
    pub id: String,
    pub user_id: Option<String>,
    pub sender: mpsc::UnboundedSender<WebSocketMessage>,
}

pub struct WebSocketService {
    clients: Arc<RwLock<HashMap<String, WebSocketClient>>>,
    message_sender: Option<mpsc::UnboundedSender<BroadcastMessage>>,
}

#[derive(Debug, Clone)]
pub struct BroadcastMessage {
    pub target: BroadcastTarget,
    pub message: WebSocketMessage,
}

#[derive(Debug, Clone)]
pub enum BroadcastTarget {
    All,
    User(String),
    Clients(Vec<String>),
}

impl WebSocketService {
    pub fn new() -> Self {
        Self {
            clients: Arc::new(RwLock::new(HashMap::new())),
            message_sender: None,
        }
    }

    pub async fn start_server(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let addr = "127.0.0.1:8080";
        let listener = TcpListener::bind(addr).await?;
        info!("WebSocket server listening on: {}", addr);

        // 创建广播消息通道
        let (broadcast_tx, mut broadcast_rx) = mpsc::unbounded_channel::<BroadcastMessage>();
        self.message_sender = Some(broadcast_tx);

        let clients = self.clients.clone();

        // 启动广播消息处理任务
        let broadcast_clients = clients.clone();
        tokio::spawn(async move {
            while let Some(broadcast_msg) = broadcast_rx.recv().await {
                let clients_lock = broadcast_clients.read().await;
                
                match &broadcast_msg.target {
                    BroadcastTarget::All => {
                        for client in clients_lock.values() {
                            let _ = client.sender.send(broadcast_msg.message.clone());
                        }
                    }
                    BroadcastTarget::User(user_id) => {
                        for client in clients_lock.values() {
                            if client.user_id.as_ref() == Some(user_id) {
                                let _ = client.sender.send(broadcast_msg.message.clone());
                            }
                        }
                    }
                    BroadcastTarget::Clients(client_ids) => {
                        for client_id in client_ids {
                            if let Some(client) = clients_lock.get(client_id) {
                                let _ = client.sender.send(broadcast_msg.message.clone());
                            }
                        }
                    }
                }
            }
        });

        // 接受WebSocket连接
        while let Ok((stream, addr)) = listener.accept().await {
            let clients = clients.clone();
            tokio::spawn(async move {
                if let Err(e) = Self::handle_connection(stream, addr, clients).await {
                    error!("Error handling WebSocket connection: {}", e);
                }
            });
        }

        Ok(())
    }

    async fn handle_connection(
        stream: TcpStream,
        addr: std::net::SocketAddr,
        clients: Arc<RwLock<HashMap<String, WebSocketClient>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        info!("New WebSocket connection from: {}", addr);

        let ws_stream = accept_async(stream).await?;
        let client_id = Uuid::new_v4().to_string();
        
        let (mut ws_sender, mut ws_receiver) = ws_stream.split();
        let (client_tx, mut client_rx) = mpsc::unbounded_channel::<WebSocketMessage>();

        // 创建客户端记录
        let client = WebSocketClient {
            id: client_id.clone(),
            user_id: None,
            sender: client_tx,
        };

        // 注册客户端
        {
            let mut clients_lock = clients.write().await;
            clients_lock.insert(client_id.clone(), client);
        }

        // 发送欢迎消息
        let welcome_msg = WebSocketMessage {
            message_type: "welcome".to_string(),
            data: serde_json::json!({
                "client_id": client_id,
                "message": "Connected to WebSocket server"
            }),
            timestamp: chrono::Utc::now(),
        };

        if let Ok(msg_str) = serde_json::to_string(&welcome_msg) {
            let _ = ws_sender.send(Message::Text(msg_str)).await;
        }

        // 启动发送任务
        let mut send_task = tokio::spawn(async move {
            while let Some(message) = client_rx.recv().await {
                if let Ok(msg_str) = serde_json::to_string(&message) {
                    if ws_sender.send(Message::Text(msg_str)).await.is_err() {
                        break;
                    }
                } else {
                    warn!("Failed to serialize WebSocket message");
                }
            }
        });

        // 启动接收任务
        let client_id_clone = client_id.clone();
        let clients_clone = clients.clone();
        let mut recv_task = tokio::spawn(async move {
            while let Some(msg) = ws_receiver.next().await {
                match msg {
                    Ok(Message::Text(text)) => {
                        if let Err(e) = Self::handle_client_message(&client_id_clone, &text, &clients_clone).await {
                            error!("Error handling client message: {}", e);
                        }
                    }
                    Ok(Message::Close(_)) => {
                        info!("Client {} requested close", client_id_clone);
                        break;
                    }
                    Err(e) => {
                        error!("WebSocket error: {}", e);
                        break;
                    }
                    _ => {}
                }
            }
        });

        // 等待任务完成
        tokio::select! {
            _ = (&mut send_task) => {
                recv_task.abort();
            }
            _ = (&mut recv_task) => {
                send_task.abort();
            }
        }

        // 清理客户端
        {
            let mut clients_lock = clients.write().await;
            clients_lock.remove(&client_id);
        }

        info!("Client {} disconnected", client_id);
        Ok(())
    }

    async fn handle_client_message(
        client_id: &str,
        message: &str,
        clients: &Arc<RwLock<HashMap<String, WebSocketClient>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let msg: serde_json::Value = serde_json::from_str(message)?;
        
        if let Some(msg_type) = msg.get("type").and_then(|v| v.as_str()) {
            match msg_type {
                "auth" => {
                    if let Some(user_id) = msg.get("user_id").and_then(|v| v.as_str()) {
                        // 更新客户端的用户ID
                        let mut clients_lock = clients.write().await;
                        if let Some(client) = clients_lock.get_mut(client_id) {
                            client.user_id = Some(user_id.to_string());
                            info!("Client {} authenticated as user {}", client_id, user_id);
                        }
                    }
                }
                "ping" => {
                    // 发送pong响应
                    if let Some(client) = clients.read().await.get(client_id) {
                        let pong_msg = WebSocketMessage {
                            message_type: "pong".to_string(),
                            data: serde_json::json!({"timestamp": chrono::Utc::now()}),
                            timestamp: chrono::Utc::now(),
                        };
                        let _ = client.sender.send(pong_msg);
                    }
                }
                _ => {
                    warn!("Unknown message type: {}", msg_type);
                }
            }
        }

        Ok(())
    }

    pub async fn broadcast_to_all(&self, message: WebSocketMessage) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(sender) = &self.message_sender {
            let broadcast_msg = BroadcastMessage {
                target: BroadcastTarget::All,
                message,
            };
            sender.send(broadcast_msg)?;
        }
        Ok(())
    }

    pub async fn send_to_user(&self, user_id: &str, message: WebSocketMessage) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(sender) = &self.message_sender {
            let broadcast_msg = BroadcastMessage {
                target: BroadcastTarget::User(user_id.to_string()),
                message,
            };
            sender.send(broadcast_msg)?;
        }
        Ok(())
    }

    pub async fn get_connected_users(&self) -> Vec<String> {
        let clients = self.clients.read().await;
        clients
            .values()
            .filter_map(|client| client.user_id.clone())
            .collect()
    }

    pub async fn get_client_count(&self) -> usize {
        self.clients.read().await.len()
    }
}

// 辅助函数：创建系统通知消息
pub fn create_system_notification(title: &str, message: &str, level: &str) -> WebSocketMessage {
    WebSocketMessage {
        message_type: "system_notification".to_string(),
        data: serde_json::json!({
            "title": title,
            "message": message,
            "level": level,
            "id": Uuid::new_v4().to_string()
        }),
        timestamp: chrono::Utc::now(),
    }
}

// 辅助函数：创建仪表板更新消息
pub fn create_dashboard_update(data: serde_json::Value) -> WebSocketMessage {
    WebSocketMessage {
        message_type: "dashboard_update".to_string(),
        data,
        timestamp: chrono::Utc::now(),
    }
}
```

### 2.4 系统监控服务 (src-tauri/src/monitoring.rs)
```rust
use crate::database::{DatabaseService, SystemMetrics, SystemResourceMetrics, NetworkMetrics, ApplicationMetrics};
use crate::websocket::{WebSocketService, create_dashboard_update, create_system_notification};

use std::sync::Arc;
use std::time::Duration;
use sysinfo::{System, SystemExt, CpuExt, DiskExt, NetworkExt, ProcessExt};
use tokio::time::sleep;
use chrono::Utc;
use serde_json::json;
use tracing::{info, error, warn};

pub struct MonitoringService {
    database: Arc<DatabaseService>,
    system: Arc<tokio::sync::Mutex<System>>,
}

#[derive(Debug, Clone)]
pub struct MonitoringConfig {
    pub collection_interval: Duration,
    pub alert_thresholds: AlertThresholds,
}

#[derive(Debug, Clone)]
pub struct AlertThresholds {
    pub cpu_warning: f64,      // CPU使用率警告阈值
    pub cpu_critical: f64,     // CPU使用率严重阈值
    pub memory_warning: f64,   // 内存使用率警告阈值
    pub memory_critical: f64,  // 内存使用率严重阈值
    pub disk_warning: f64,     // 磁盘使用率警告阈值
    pub disk_critical: f64,    // 磁盘使用率严重阈值
}

impl Default for AlertThresholds {
    fn default() -> Self {
        Self {
            cpu_warning: 70.0,
            cpu_critical: 90.0,
            memory_warning: 80.0,
            memory_critical: 95.0,
            disk_warning: 85.0,
            disk_critical: 95.0,
        }
    }
}

impl MonitoringService {
    pub fn new(database: Arc<DatabaseService>) -> Self {
        let mut system = System::new_all();
        system.refresh_all();
        
        Self {
            database,
            system: Arc::new(tokio::sync::Mutex::new(system)),
        }
    }

    pub async fn start_system_monitoring(&self) -> Result<(), Box<dyn std::error::Error>> {
        let config = MonitoringConfig {
            collection_interval: Duration::from_secs(30), // 每30秒收集一次
            alert_thresholds: AlertThresholds::default(),
        };

        info!("Starting system monitoring with interval: {:?}", config.collection_interval);

        loop {
            if let Err(e) = self.collect_and_store_metrics(&config).await {
                error!("Error collecting system metrics: {}", e);
            }

            sleep(config.collection_interval).await;
        }
    }

    async fn collect_and_store_metrics(&self, config: &MonitoringConfig) -> Result<(), Box<dyn std::error::Error>> {
        // 刷新系统信息
        {
            let mut system = self.system.lock().await;
            system.refresh_all();
        }

        // 收集系统指标
        let system_metrics = self.collect_system_metrics().await?;
        
        // 收集应用指标
        let app_metrics = self.collect_application_metrics().await?;

        // 创建指标记录
        let metrics = SystemMetrics {
            id: None,
            timestamp: Utc::now(),
            metrics: system_metrics.clone(),
            application_metrics: app_metrics.clone(),
        };

        // 存储到数据库
        if let Err(e) = self.database.save_system_metrics(metrics).await {
            error!("Failed to save system metrics: {}", e);
        }

        // 检查告警条件
        self.check_alerts(&system_metrics, &config.alert_thresholds).await;

        // 构建仪表板数据
        let dashboard_data = json!({
            "system_metrics": {
                "cpu_usage": system_metrics.cpu_usage,
                "memory_usage": system_metrics.memory_usage,
                "disk_usage": system_metrics.disk_usage,
                "network_io": system_metrics.network_io
            },
            "application_metrics": {
                "active_users": app_metrics.active_users,
                "concurrent_sessions": app_metrics.concurrent_sessions,
                "tool_usage_count": app_metrics.tool_usage_count,
                "error_count": app_metrics.error_count
            },
            "timestamp": Utc::now()
        });

        info!("Collected metrics - CPU: {:.1}%, Memory: {:.1}%, Disk: {:.1}%",
            system_metrics.cpu_usage,
            system_metrics.memory_usage,
            system_metrics.disk_usage
        );

        Ok(())
    }

    async fn collect_system_metrics(&self) -> Result<SystemResourceMetrics, Box<dyn std::error::Error>> {
        let system = self.system.lock().await;

        // CPU使用率
        let cpu_usage = system.global_cpu_info().cpu_usage() as f64;

        // 内存使用率
        let total_memory = system.total_memory();
        let used_memory = system.used_memory();
        let memory_usage = if total_memory > 0 {
            (used_memory as f64 / total_memory as f64) * 100.0
        } else {
            0.0
        };

        // 磁盘使用率（取主要磁盘）
        let mut disk_usage = 0.0;
        if let Some(disk) = system.disks().first() {
            let total_space = disk.total_space();
            let available_space = disk.available_space();
            let used_space = total_space - available_space;
            
            if total_space > 0 {
                disk_usage = (used_space as f64 / total_space as f64) * 100.0;
            }
        }

        // 网络IO（累计值）
        let mut bytes_sent = 0u64;
        let mut bytes_received = 0u64;
        
        for (_, network) in system.networks() {
            bytes_sent += network.total_transmitted();
            bytes_received += network.total_received();
        }

        Ok(SystemResourceMetrics {
            cpu_usage,
            memory_usage,
            disk_usage,
            network_io: NetworkMetrics {
                bytes_sent,
                bytes_received,
            },
        })
    }

    async fn collect_application_metrics(&self) -> Result<ApplicationMetrics, Box<dyn std::error::Error>> {
        // 这里需要实现应用级别的指标收集
        // 由于是示例，使用模拟数据
        
        // 在实际实现中，这些数据应该从：
        // 1. WebSocket服务获取活跃用户和并发会话数
        // 2. 数据库查询获取工具使用统计
        // 3. 错误日志系统获取错误数量

        Ok(ApplicationMetrics {
            active_users: 12,      // 从WebSocket服务获取
            concurrent_sessions: 8, // 从会话管理获取
            tool_usage_count: 156,  // 从数据库统计今日工具使用次数
            error_count: 3,         // 从错误日志统计今日错误数量
        })
    }

    async fn check_alerts(&self, metrics: &SystemResourceMetrics, thresholds: &AlertThresholds) {
        // 检查CPU告警
        if metrics.cpu_usage >= thresholds.cpu_critical {
            let msg = create_system_notification(
                "严重告警",
                &format!("CPU使用率过高: {:.1}%", metrics.cpu_usage),
                "error"
            );
            // 这里需要通过WebSocket发送告警
            warn!("Critical CPU usage: {:.1}%", metrics.cpu_usage);
        } else if metrics.cpu_usage >= thresholds.cpu_warning {
            let msg = create_system_notification(
                "警告",
                &format!("CPU使用率较高: {:.1}%", metrics.cpu_usage),
                "warning"
            );
            warn!("High CPU usage: {:.1}%", metrics.cpu_usage);
        }

        // 检查内存告警
        if metrics.memory_usage >= thresholds.memory_critical {
            let msg = create_system_notification(
                "严重告警",
                &format!("内存使用率过高: {:.1}%", metrics.memory_usage),
                "error"
            );
            warn!("Critical memory usage: {:.1}%", metrics.memory_usage);
        } else if metrics.memory_usage >= thresholds.memory_warning {
            let msg = create_system_notification(
                "警告",
                &format!("内存使用率较高: {:.1}%", metrics.memory_usage),
                "warning"
            );
            warn!("High memory usage: {:.1}%", metrics.memory_usage);
        }

        // 检查磁盘告警
        if metrics.disk_usage >= thresholds.disk_critical {
            let msg = create_system_notification(
                "严重告警",
                &format!("磁盘使用率过高: {:.1}%", metrics.disk_usage),
                "error"
            );
            warn!("Critical disk usage: {:.1}%", metrics.disk_usage);
        } else if metrics.disk_usage >= thresholds.disk_warning {
            let msg = create_system_notification(
                "警告",
                &format!("磁盘使用率较高: {:.1}%", metrics.disk_usage),
                "warning"
            );
            warn!("High disk usage: {:.1}%", metrics.disk_usage);
        }
    }

    pub async fn get_system_health(&self) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let metrics = self.collect_system_metrics().await?;
        let app_metrics = self.collect_application_metrics().await?;

        Ok(json!({
            "status": "healthy",
            "timestamp": Utc::now(),
            "system": {
                "cpu_usage": metrics.cpu_usage,
                "memory_usage": metrics.memory_usage,
                "disk_usage": metrics.disk_usage,
                "network_io": metrics.network_io
            },
            "application": {
                "active_users": app_metrics.active_users,
                "concurrent_sessions": app_metrics.concurrent_sessions,
                "tool_usage_count": app_metrics.tool_usage_count,
                "error_count": app_metrics.error_count
            }
        }))
    }
}

// Tauri命令实现
#[tauri::command]
pub async fn get_system_metrics(
    state: tauri::State<'_, crate::AppState>,
) -> Result<serde_json::Value, String> {
    state.monitoring.get_system_health().await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_user_activities(
    state: tauri::State<'_, crate::AppState>,
    user_id: String,
    limit: i64,
) -> Result<Vec<crate::database::UserActivity>, String> {
    use mongodb::bson::oid::ObjectId;
    
    let user_object_id = ObjectId::parse_str(&user_id)
        .map_err(|e| format!("Invalid user ID: {}", e))?;
    
    state.database.get_user_activities(user_object_id, limit).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_dashboard_data(
    state: tauri::State<'_, crate::AppState>,
) -> Result<serde_json::Value, String> {
    // 获取系统指标
    let system_health = state.monitoring.get_system_health().await
        .map_err(|e| e.to_string())?;
    
    // 获取最近的活动日志（示例数据）
    let recent_activities = json!([
        {
            "id": "1",
            "user_id": "user1",
            "activity_type": "login",
            "timestamp": Utc::now(),
            "success": true
        },
        {
            "id": "2",
            "user_id": "user2",
            "activity_type": "tool_access",
            "tool_name": "商家回复解答手册",
            "timestamp": Utc::now(),
            "success": true
        }
    ]);

    // 获取告警信息（示例数据）
    let alerts = json!([]);

    Ok(json!({
        "system_metrics": system_health["system"],
        "application_metrics": system_health["application"],
        "recent_activities": recent_activities,
        "alerts": alerts,
        "timestamp": Utc::now()
    }))
}
```


## Phase 3: 部署配置与安全策略实现

### 3.0 Windows开发环境配置解决方案

#### Microsoft C++构建工具问题解决
当前项目在Windows环境下需要Microsoft C++构建工具支持，已提供完整解决方案：

**方案一：安装 Visual Studio Build Tools 2022（强烈推荐）**
```bash
# 下载地址：https://visualstudio.microsoft.com/downloads/
# 或直接下载：https://aka.ms/vs/17/release/vs_buildtools.exe

# 在 Visual Studio Installer 中选择：
# ✅ C++ 生成工具
# ✅ Windows 10/11 SDK（最新版本）
# ✅ MSVC v143 - VS 2022 C++ x64/x86 生成工具
# ✅ CMake 工具（可选但推荐）
```

**方案二：使用 GNU 工具链（临时方案）**
```bash
rustup toolchain install stable-x86_64-pc-windows-gnu
rustup default stable-x86_64-pc-windows-gnu
```

**验证安装**
```bash
# 检查 Microsoft C++ 链接器
where link.exe

# 检查 Rust 工具链
rustc --version
rustup show
```

### 3.1 NSIS安装包构建完整方案

项目已采用NSIS作为Windows平台的专业安装包解决方案，相比直接EXE分发具有显著优势：

#### NSIS vs 其他方案对比

| 特性 | 直接EXE | MSI | NSIS |
|------|---------|-----|------|
| **用户体验** | ⚠️ 简单 | ✅ 专业 | ✅ **最佳** |
| **依赖检测** | ❌ 无 | ⚠️ 基础 | ✅ **智能** |
| **安装定制** | ❌ 无 | ⚠️ 有限 | ✅ **完全可定制** |
| **错误处理** | ❌ 系统级 | ⚠️ 基础 | ✅ **用户友好** |
| **企业部署** | ❌ 困难 | ✅ 支持 | ✅ **完全支持** |

#### NSIS核心优势
1. **智能依赖管理** - 自动检测WebView2运行时，提供清晰的安装指导
2. **专业安装体验** - 现代化安装界面，进度显示和状态反馈
3. **企业级部署** - 静默安装支持，批量部署脚本，组策略兼容

#### 构建配置更新
```json
{
  "bundle": {
    "active": true,
    "targets": ["nsis"],
    "publisher": "呈尚策划",
    "category": "Productivity",
    "shortDescription": "呈尚策划专业工具集合",
    "longDescription": "集成19个专业工具的桌面应用，服务于运营、美工、销售、人事、客服等不同岗位的工作需求",
    "nsis": {
      "displayLanguageSelector": false,
      "installerIcon": "icons/icon.ico",
      "installMode": "perMachine",
      "allowToChangeInstallationDirectory": true,
      "deleteAppDataOnUninstall": false,
      "shortcutName": "呈尚策划工具箱",
      "publisherName": "呈尚策划"
    }
  }
}
```

#### 标准构建流程
```bash
# 1. 清理之前的构建
cargo clean
rm -rf src-tauri/target/release/bundle

# 2. 安装/更新依赖
pnpm install

# 3. 执行完整构建
npm run tauri:build

# 4. 验证构建结果
ls -la src-tauri/target/release/bundle/nsis/
# 输出：呈尚策划项目展示_1.0.0_x64-setup.exe (20-35MB)
```

#### 构建产物分析
```
src-tauri/target/release/
├── app.exe                                    # 主程序 (15-25MB)
├── bundle/
│   └── nsis/
│       └── 呈尚策划项目展示_1.0.0_x64-setup.exe  # NSIS安装包 (20-35MB)
├── resources/                                 # 应用资源
└── deps/                                      # 依赖库文件
```

#### 质量检查清单
**✅ 文件完整性**
- [ ] NSIS安装包已生成
- [ ] 文件大小在合理范围 (20-35MB)
- [ ] 文件名包含正确版本号
- [ ] 图标显示正确

**✅ 安装测试**
- [ ] 安装程序可以启动
- [ ] 安装过程无错误
- [ ] 进度显示正常
- [ ] 安装路径可选择

**✅ 功能测试**
- [ ] 应用可以正常启动
- [ ] 所有19个工具可访问
- [ ] WebView功能正常
- [ ] 快捷方式工作正常

#### 企业部署支持
```bash
# 静默安装命令
"呈尚策划项目展示_1.0.0_x64-setup.exe" /S

# 指定安装路径
"呈尚策划项目展示_1.0.0_x64-setup.exe" /S /D=C:\Program Files\ChengShangCeHua
```

### 3.2 自动更新服务器完整配置方案

项目已实现完整的自动更新机制，支持安全的应用版本管理和推送：

#### 更新机制流程
```mermaid
graph TB
    A[应用启动] --> B[检查更新<br/>延迟3秒]
    B --> C{发现新版本?}
    C -->|是| D[显示更新对话框]
    C -->|否| E[正常运行]
    D --> F[用户确认]
    F --> G[下载更新包]
    G --> H[验证数字签名]
    H --> I[自动重启应用]
    I --> J[新版本生效]
```

#### 数字签名密钥配置
```bash
# 生成签名密钥对
cargo install tauri-cli
tauri signer generate -w ~/.tauri/chengshang.key

# 输出示例：
# Private key: ~/.tauri/chengshang.key
# Public key: dW50cnVzdGVkIGNvbW1lbnQ6IHNpZ25hdHVyZSBmcm9tIHRhdXJpIHNlY3JldCBrZXkK...
```

#### Tauri配置更新
```json
{
  "updater": {
    "active": true,
    "endpoints": [
      "https://api.chengshangcehua.com/releases/{{target}}/{{current_version}}"
    ],
    "dialog": true,
    "pubkey": "dW50cnVzdGVkIGNvbW1lbnQ6IHNpZ25hdHVyZSBmcm9tIHRhdXJpIHNlY3JldCBrZXkK..."
  }
}
```

#### 更新服务器API规范
```javascript
// 响应格式（有更新时）
{
  "version": "1.1.0",
  "notes": "修复了若干问题，新增了自动更新功能",
  "pub_date": "2025-07-29T10:00:00Z",
  "platforms": {
    "windows-x86_64": {
      "signature": "dW50cnVzdGVkIGNvbW1lbnQ6IHNpZ25hdHVyZSBmcm9tIHRhdXJpIHNlY3JldCBrZXkK...",
      "url": "https://api.chengshangcehua.com/releases/v1.1.0/app-setup.exe"
    }
  }
}

// 响应格式（无更新时）
{
  "version": "1.0.0",
  "notes": "当前已是最新版本",
  "pub_date": "2025-07-29T10:00:00Z"
}
```

#### GitHub Actions自动化发布
```yaml
# .github/workflows/release.yml
name: Release
on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        
      - name: Install dependencies
        run: pnpm install
        
      - name: Build and release
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
        run: npm run tauri:build
          
      - name: Create Release
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'Release ${{ github.ref_name }}'
          releaseBody: 'See the assets to download and install this version.'
```

#### 版本发布流程
```bash
# 1. 更新版本号
node scripts/update-version.js 1.1.0

# 2. 设置私钥环境变量
export TAURI_PRIVATE_KEY="$(cat ~/.tauri/chengshang.key)"

# 3. 构建应用（自动签名）
npm run tauri:build

# 4. 上传到发布服务器
scp src-tauri/target/release/bundle/nsis/*.exe user@server:/var/www/releases/
```

#### 安全策略
- ✅ **Ed25519数字签名** - 防止恶意软件替换
- ✅ **HTTPS传输** - 防止中间人攻击
- ✅ **版本验证** - 防止版本回滚攻击
- ✅ **签名完整性检查** - 确保更新包未被篡改

### 3.3 多层次开发者工具保护机制

为保护应用源代码和防止用户误操作，实现了企业级的多层次保护：

#### 保护层级架构
```mermaid
graph TB
    A[用户操作] --> B[浏览器事件层]
    B --> C[JavaScript拦截]
    C --> D[CSS样式保护]
    D --> E[Tauri配置层]
    E --> F[系统级禁用]
    
    G[保护功能] --> H[F12开发者工具]
    G --> I[右键菜单检查]
    G --> J[快捷键拦截]
    G --> K[文本选择禁用]
    G --> L[页面保存阻止]
```

#### 层级1: Tauri配置层保护
```json
{
  "app": {
    "windows": [
      {
        "devtools": false
      }
    ]
  }
}
```

#### 层级2: JavaScript事件拦截
```typescript
// 禁用的快捷键组合
const disabledKeys = [
  'F12',                    // 开发者工具
  'Ctrl+Shift+I',          // 开发者工具
  'Ctrl+Shift+J',          // 控制台
  'Ctrl+U',                // 查看源代码
  'Ctrl+Shift+C',          // 选择元素
  'Ctrl+S',                // 保存页面
  'Ctrl+A',                // 全选
  'Ctrl+P'                 // 打印
];

// 事件拦截实现
const disableDevToolsKeys = (e: KeyboardEvent) => {
  if (e.key === 'F12' ||
      (e.ctrlKey && e.shiftKey && e.key === 'I') ||
      (e.ctrlKey && e.shiftKey && e.key === 'J')) {
    e.preventDefault();
    return false;
  }
};

document.addEventListener('keydown', disableDevToolsKeys);
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  return false;
});
```

#### 层级3: CSS样式保护
```css
/* 禁用文本选择 */
* {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* 禁用右键菜单 */
body {
  -webkit-context-menu: none;
  -moz-context-menu: none;
  context-menu: none;
}

/* 禁用拖拽 */
* {
  -webkit-user-drag: none;
  -moz-user-drag: none;
  user-drag: none;
}
```

#### 开发者工具检测
```typescript
const detectDevTools = () => {
  const threshold = 160;
  setInterval(() => {
    if (
      window.outerHeight - window.innerHeight > threshold ||
      window.outerWidth - window.innerWidth > threshold
    ) {
      console.clear(); // 清空控制台
      // 可选：显示警告信息或采取其他保护措施
    }
  }, 500);
};
```

#### 保护效果总结
**✅ 已禁用的功能**
1. F12键无法打开开发者工具
2. 右键菜单无法访问"检查元素"
3. 所有开发者工具相关快捷键被拦截
4. 无法选择和复制页面文本
5. 无法通过Ctrl+S保存页面
6. 无法通过Ctrl+U查看源代码
7. 防止拖拽文件到页面

**⚠️ 例外情况**
- 输入框仍然可以选择和编辑文本
- 开发环境下可以临时禁用保护机制

#### 安全策略补充建议
1. **代码混淆** - 在构建时混淆JavaScript代码
2. **服务端验证** - 重要操作在服务端验证
3. **加密通信** - 使用HTTPS和其他加密措施
4. **访问控制** - 实现用户权限管理

**注意**: 这些保护措施主要针对普通用户的误操作和基本的代码保护，不能替代完整的安全策略。

### 3.1 统一错误处理系统 (src-tauri/src/error.rs)
```rust
use thiserror::Error;
use serde::{Deserialize, Serialize};

#[derive(Error, Debug, Serialize, Deserialize)]
pub enum AuthError {
    #[error("Invalid credentials")]
    InvalidCredentials,
    
    #[error("User not found")]
    UserNotFound,
    
    #[error("User is inactive")]
    UserInactive,
    
    #[error("Invalid token")]
    InvalidToken,
    
    #[error("Token generation failed")]
    TokenGenerationFailed,
    
    #[error("Password hashing failed")]
    PasswordHashingFailed,
    
    #[error("Too many login attempts")]
    TooManyLoginAttempts,
    
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Session expired")]
    SessionExpired,
    
    #[error("Insufficient permissions")]
    InsufficientPermissions,
}

#[derive(Error, Debug, Serialize, Deserialize)]
pub enum ApplicationError {
    #[error("Tool not found: {0}")]
    ToolNotFound(String),
    
    #[error("Tool launch failed: {0}")]
    ToolLaunchFailed(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("File system error: {0}")]
    FileSystemError(String),
    
    #[error("Database connection failed: {0}")]
    DatabaseConnectionFailed(String),
    
    #[error("WebSocket error: {0}")]
    WebSocketError(String),
    
    #[error("Monitoring error: {0}")]
    MonitoringError(String),
}

#[derive(Error, Debug, Serialize, Deserialize)]
pub enum ValidationError {
    #[error("Invalid input: {field}")]
    InvalidInput { field: String },
    
    #[error("Missing required field: {field}")]
    MissingField { field: String },
    
    #[error("Invalid format: {field}")]
    InvalidFormat { field: String },
    
    #[error("Value out of range: {field}")]
    OutOfRange { field: String },
}

// 统一错误响应结构
#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
    pub code: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub details: Option<serde_json::Value>,
}

impl ErrorResponse {
    pub fn new(error: &str, message: &str, code: &str) -> Self {
        Self {
            error: error.to_string(),
            message: message.to_string(),
            code: code.to_string(),
            timestamp: chrono::Utc::now(),
            details: None,
        }
    }
    
    pub fn with_details(mut self, details: serde_json::Value) -> Self {
        self.details = Some(details);
        self
    }
}

// 错误处理工具函数
pub fn handle_auth_error(error: AuthError) -> ErrorResponse {
    match error {
        AuthError::InvalidCredentials => ErrorResponse::new(
            "INVALID_CREDENTIALS",
            "用户名或密码错误",
            "AUTH_001"
        ),
        AuthError::UserNotFound => ErrorResponse::new(
            "USER_NOT_FOUND",
            "用户不存在",
            "AUTH_002"
        ),
        AuthError::UserInactive => ErrorResponse::new(
            "USER_INACTIVE",
            "用户账户已被禁用",
            "AUTH_003"
        ),
        AuthError::InvalidToken => ErrorResponse::new(
            "INVALID_TOKEN",
            "令牌无效或已过期",
            "AUTH_004"
        ),
        AuthError::TooManyLoginAttempts => ErrorResponse::new(
            "TOO_MANY_ATTEMPTS",
            "登录尝试过于频繁，请稍后再试",
            "AUTH_005"
        ),
        _ => ErrorResponse::new(
            "AUTH_ERROR",
            "认证系统错误",
            "AUTH_999"
        ),
    }
}
```

### 3.2 服务管理容器 (src-tauri/src/services/mod.rs)
```rust
pub mod tools;
pub mod admin;
pub mod audit;

use std::sync::Arc;
use crate::database::DatabaseService;
use crate::auth::AuthService;
use crate::config::AppConfig;

pub struct ServiceContainer {
    pub database: Arc<DatabaseService>,
    pub auth: Arc<AuthService>,
    pub config: Arc<AppConfig>,
}

impl ServiceContainer {
    pub fn new(
        database: Arc<DatabaseService>,
        auth: Arc<AuthService>,
        config: Arc<AppConfig>,
    ) -> Self {
        Self {
            database,
            auth,
            config,
        }
    }
}
```

### 3.3 工具管理服务 (src-tauri/src/services/tools.rs)
```rust
use crate::database::{DatabaseService, UserActivity, ActivityDetails, ActivityMetadata};
use crate::error::ApplicationError;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use chrono::Utc;
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
pub struct Tool {
    pub id: u32,
    pub name: String,
    pub description: String,
    pub category: String,
    pub url: String,
    pub icon: String,
    pub rating: f32,
    pub downloads: String,
    pub tags: Vec<String>,
    pub color: String,
    pub featured: bool,
    pub last_updated: String,
    pub tool_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ToolUsageRequest {
    pub tool_id: u32,
    pub user_id: String,
    pub session_id: String,
    pub device_info: serde_json::Value,
}

pub struct ToolService {
    database: Arc<DatabaseService>,
}

impl ToolService {
    pub fn new(database: Arc<DatabaseService>) -> Self {
        Self { database }
    }

    pub async fn get_all_tools(&self) -> Result<Vec<Tool>, ApplicationError> {
        Ok(self.get_tools_data())
    }

    pub async fn get_tools_by_category(&self, category: &str) -> Result<Vec<Tool>, ApplicationError> {
        let all_tools = self.get_all_tools().await?;
        let filtered_tools: Vec<Tool> = all_tools
            .into_iter()
            .filter(|tool| tool.category == category)
            .collect();
        Ok(filtered_tools)
    }

    pub async fn launch_tool(&self, tool_id: u32, user_id: &str) -> Result<String, ApplicationError> {
        let tools = self.get_all_tools().await?;
        let tool = tools
            .iter()
            .find(|t| t.id == tool_id)
            .ok_or_else(|| ApplicationError::ToolNotFound(tool_id.to_string()))?;

        // 记录工具使用活动
        self.log_tool_usage(tool, user_id, true, None).await?;

        // 根据工具类型执行不同的启动逻辑
        match tool.tool_type.as_str() {
            "web" => {
                self.launch_web_tool(&tool.url).await
            }
            "desktop" => {
                self.launch_desktop_tool(tool).await
            }
            "integrated" => {
                self.launch_integrated_tool(tool).await
            }
            _ => Err(ApplicationError::ToolLaunchFailed(
                "Unsupported tool type".to_string()
            ))
        }
    }

    async fn launch_web_tool(&self, url: &str) -> Result<String, ApplicationError> {
        use tauri::api::shell;
        
        shell::open(&Default::default(), url, None)
            .map_err(|e| ApplicationError::ToolLaunchFailed(e.to_string()))?;
        
        Ok(format!("Web tool launched: {}", url))
    }

    async fn launch_desktop_tool(&self, tool: &Tool) -> Result<String, ApplicationError> {
        match tool.name.as_str() {
            "微信群发助手" => {
                self.launch_wechat_helper().await
            }
            _ => Err(ApplicationError::ToolLaunchFailed(
                "Desktop tool not implemented".to_string()
            ))
        }
    }

    async fn launch_integrated_tool(&self, tool: &Tool) -> Result<String, ApplicationError> {
        Ok(format!("Integrated tool launched: {}", tool.name))
    }

    async fn launch_wechat_helper(&self) -> Result<String, ApplicationError> {
        Ok("WeChat helper launched successfully".to_string())
    }

    async fn log_tool_usage(
        &self,
        tool: &Tool,
        user_id: &str,
        success: bool,
        error_message: Option<String>,
    ) -> Result<(), ApplicationError> {
        use mongodb::bson::oid::ObjectId;

        let user_object_id = ObjectId::parse_str(user_id)
            .map_err(|e| ApplicationError::DatabaseConnectionFailed(e.to_string()))?;

        let activity = UserActivity {
            id: None,
            user_id: user_object_id,
            activity_type: "tool_access".to_string(),
            tool_id: Some(tool.id),
            details: ActivityDetails {
                tool_name: Some(tool.name.clone()),
                duration: None,
                success,
                error_message,
            },
            metadata: ActivityMetadata {
                ip_address: "127.0.0.1".to_string(),
                user_agent: "Tauri Application".to_string(),
                session_id: Uuid::new_v4().to_string(),
            },
            timestamp: Utc::now(),
        };

        self.database.log_user_activity(activity).await
            .map_err(|e| ApplicationError::DatabaseConnectionFailed(e.to_string()))?;

        Ok(())
    }

    fn get_tools_data(&self) -> Vec<Tool> {
        // 返回19个工具的完整数据
        vec![
            Tool {
                id: 1,
                name: "商家回复解答手册".to_string(),
                description: "提供标准化的客户反馈处理模板和沟通技巧".to_string(),
                category: "运营工具".to_string(),
                url: "https://xuxikai886.github.io/shangjiahuizong/".to_string(),
                icon: "MessageSquare".to_string(),
                rating: 4.8,
                downloads: "2.1k".to_string(),
                tags: vec!["回复模板".to_string(), "沟通技巧".to_string(), "客户反馈".to_string()],
                color: "from-blue-500 to-blue-600".to_string(),
                featured: true,
                last_updated: "2天前".to_string(),
                tool_type: "web".to_string(),
            },
            // ... 其他18个工具的数据
            Tool {
                id: 19,
                name: "外卖店铺信息采集系统".to_string(),
                description: "批量采集外卖店铺基础信息".to_string(),
                category: "客服工具".to_string(),
                url: "https://xuxikai886.github.io/meituandianpuxinxicaiji/".to_string(),
                icon: "Search".to_string(),
                rating: 4.9,
                downloads: "3.2k".to_string(),
                tags: vec!["自动解析".to_string(), "批量处理".to_string(), "Excel导出".to_string()],
                color: "from-pink-500 to-pink-600".to_string(),
                featured: true,
                last_updated: "1天前".to_string(),
                tool_type: "web".to_string(),
            },
        ]
    }
}

// Tauri命令实现
#[tauri::command]
pub async fn get_tools(
    state: tauri::State<'_, crate::AppState>,
) -> Result<Vec<Tool>, String> {
    let tool_service = ToolService::new(state.db.clone());
    tool_service.get_all_tools().await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn launch_tool(
    state: tauri::State<'_, crate::AppState>,
    tool_id: u32,
    user_id: String,
) -> Result<String, String> {
    let tool_service = ToolService::new(state.db.clone());
    tool_service.launch_tool(tool_id, &user_id).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn track_usage(
    state: tauri::State<'_, crate::AppState>,
    request: ToolUsageRequest,
) -> Result<(), String> {
    // 记录使用统计
    Ok(())
}
```

### 3.4 安全策略与审计日志 (src-tauri/src/services/audit.rs)
```rust
use crate::database::DatabaseService;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use chrono::Utc;
use mongodb::bson::oid::ObjectId;

#[derive(Debug, Serialize, Deserialize)]
pub struct AuditLog {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub user_id: ObjectId,
    pub action: String,
    pub resource: String,
    pub resource_id: String,
    pub old_values: Option<serde_json::Value>,
    pub new_values: Option<serde_json::Value>,
    pub ip_address: String,
    pub user_agent: String,
    pub success: bool,
    pub error_message: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityEvent {
    pub event_type: String,
    pub severity: String, // LOW, MEDIUM, HIGH, CRITICAL
    pub description: String,
    pub user_id: Option<String>,
    pub ip_address: String,
    pub user_agent: String,
    pub metadata: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

pub struct AuditService {
    database: Arc<DatabaseService>,
}

impl AuditService {
    pub fn new(database: Arc<DatabaseService>) -> Self {
        Self { database }
    }

    pub async fn log_audit_event(
        &self,
        user_id: ObjectId,
        action: &str,
        resource: &str,
        resource_id: &str,
        old_values: Option<serde_json::Value>,
        new_values: Option<serde_json::Value>,
        ip_address: &str,
        user_agent: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let audit_log = AuditLog {
            id: None,
            user_id,
            action: action.to_string(),
            resource: resource.to_string(),
            resource_id: resource_id.to_string(),
            old_values,
            new_values,
            ip_address: ip_address.to_string(),
            user_agent: user_agent.to_string(),
            success: true,
            error_message: None,
            timestamp: Utc::now(),
        };

        // 这里需要在DatabaseService中实现save_audit_log方法
        // self.database.save_audit_log(audit_log).await?;
        
        Ok(())
    }

    pub async fn log_security_event(&self, event: SecurityEvent) -> Result<(), Box<dyn std::error::Error>> {
        tracing::warn!(
            "Security event: {} - {} - {:?}", 
            event.event_type, 
            event.severity, 
            event.description
        );
        
        Ok(())
    }

    pub async fn check_suspicious_activity(&self, user_id: &str, ip_address: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // 实现可疑活动检测逻辑
        Ok(false)
    }

    pub async fn get_user_audit_trail(
        &self, 
        user_id: &str, 
        from_date: chrono::DateTime<chrono::Utc>,
        to_date: chrono::DateTime<chrono::Utc>
    ) -> Result<Vec<AuditLog>, Box<dyn std::error::Error>> {
        Ok(vec![])
    }
}

// 安全策略配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityPolicy {
    pub password_policy: PasswordPolicy,
    pub session_policy: SessionPolicy,
    pub access_policy: AccessPolicy,
    pub audit_policy: AuditPolicy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PasswordPolicy {
    pub min_length: u32,
    pub require_uppercase: bool,
    pub require_lowercase: bool,
    pub require_numbers: bool,
    pub require_special_chars: bool,
    pub password_history: u32,
    pub max_age_days: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionPolicy {
    pub max_concurrent_sessions: u32,
    pub idle_timeout_minutes: u32,
    pub absolute_timeout_hours: u32,
    pub require_reauth_for_sensitive_ops: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessPolicy {
    pub max_login_attempts: u32,
    pub lockout_duration_minutes: u32,
    pub ip_whitelist: Vec<String>,
    pub ip_blacklist: Vec<String>,
    pub geo_restrictions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditPolicy {
    pub log_all_user_actions: bool,
    pub log_system_events: bool,
    pub log_security_events: bool,
    pub retention_days: u32,
    pub real_time_alerts: bool,
}

impl Default for SecurityPolicy {
    fn default() -> Self {
        Self {
            password_policy: PasswordPolicy {
                min_length: 8,
                require_uppercase: true,
                require_lowercase: true,
                require_numbers: true,
                require_special_chars: true,
                password_history: 5,
                max_age_days: 90,
            },
            session_policy: SessionPolicy {
                max_concurrent_sessions: 3,
                idle_timeout_minutes: 60,
                absolute_timeout_hours: 8,
                require_reauth_for_sensitive_ops: true,
            },
            access_policy: AccessPolicy {
                max_login_attempts: 5,
                lockout_duration_minutes: 15,
                ip_whitelist: vec![],
                ip_blacklist: vec![],
                geo_restrictions: vec![],
            },
            audit_policy: AuditPolicy {
                log_all_user_actions: true,
                log_system_events: true,
                log_security_events: true,
                retention_days: 365,
                real_time_alerts: true,
            },
        }
    }
}
```

### 3.5 生产环境配置 (src-tauri/tauri.conf.json)
```json
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devPath": "http://localhost:3000",
    "distDir": "../out"
  },
  "package": {
    "productName": "呈尚策划工具箱",
    "version": "2.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      },
      "window": {
        "all": false,
        "close": true,
        "hide": true,
        "show": true,
        "maximize": true,
        "minimize": true,
        "unmaximize": true,
        "unminimize": true,
        "startDragging": true
      },
      "fs": {
        "all": false,
        "readFile": true,
        "writeFile": true,
        "readDir": true,
        "createDir": true,
        "removeDir": false,
        "removeFile": false,
        "scope": ["$APPDATA/chengshang-tools/*"]
      },
      "http": {
        "all": false,
        "request": true,
        "scope": [
          "https://api.chengshangcehua.com/*",
          "wss://api.chengshangcehua.com/*"
        ]
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.chengshang.tools",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "resources": [],
      "externalBin": [],
      "copyright": "© 2024 呈尚策划",
      "category": "Business",
      "shortDescription": "专业的桌面工具箱应用",
      "longDescription": "集成19个专业工具的桌面应用，提供运营、美工、销售、人事、客服等多岗位工作支持"
    },
    "security": {
      "csp": "default-src 'self'; connect-src 'self' https: wss:; img-src 'self' data: https:; style-src 'self' 'unsafe-inline';"
    },
    "windows": [
      {
        "fullscreen": false,
        "height": 800,
        "resizable": true,
        "title": "呈尚策划工具箱",
        "width": 1200,
        "minWidth": 1000,
        "minHeight": 700,
        "center": true,
        "decorations": true,
        "alwaysOnTop": false,
        "skipTaskbar": false
      }
    ],
    "systemTray": {
      "iconPath": "icons/icon.png",
      "iconAsTemplate": true,
      "menuOnLeftClick": false
    },
    "updater": {
      "active": true,
      "endpoints": [
        "https://api.chengshangcehua.com/updates/{{target}}/{{arch}}/{{current_version}}"
      ],
      "dialog": true,
      "pubkey": "dW50cnVzdGVkIGNvbW1lbnQ6IG1pbmlzaWduIHB1YmxpYyBrZXk6IDhCOEVCQzE5NEY4QkE4MjcKUldTZGhhZjRrKzR6Y2FzQkNyZTJPYklXclJ5dDRqa21TZUpMZlN0MGJCbmhLOGNldGhRZnBLU3cK"
    }
  }
}
```

### 3.6 Docker 部署配置 (Dockerfile)
```dockerfile
# 构建阶段
FROM node:18-alpine AS frontend-builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# Rust构建阶段
FROM rust:1.75-alpine AS backend-builder

RUN apk add --no-cache musl-dev

WORKDIR /app
COPY src-tauri/Cargo.toml src-tauri/Cargo.lock ./
COPY src-tauri/src ./src

RUN cargo build --release

# 生产阶段
FROM alpine:latest

RUN apk add --no-cache ca-certificates

WORKDIR /app

# 复制构建结果
COPY --from=frontend-builder /app/out ./web
COPY --from=backend-builder /app/target/release/chengshang-tools ./

# 创建非root用户
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup

USER appuser

EXPOSE 8080

CMD ["./chengshang-tools"]
```

### 3.7 部署脚本 (deploy.sh)
```bash
#!/bin/bash

# 呈尚策划工具箱部署脚本

set -e

# 配置变量
APP_NAME="chengshang-tools"
VERSION="2.0.0"
DEPLOY_DIR="/opt/chengshang-tools"
SERVICE_USER="chengshang"
MONGODB_URL=${MONGODB_URL:-"mongodb://localhost:27017/chengshang_tools"}
JWT_SECRET=${JWT_SECRET:-"change-this-in-production"}

echo "🚀 开始部署呈尚策划工具箱 v${VERSION}"

# 检查依赖
command -v docker >/dev/null 2>&1 || { echo "❌ Docker 未安装"; exit 1; }
command -v docker-compose >/dev/null 2>&1 || { echo "❌ Docker Compose 未安装"; exit 1; }

# 创建部署目录
sudo mkdir -p ${DEPLOY_DIR}
sudo chown ${SERVICE_USER}:${SERVICE_USER} ${DEPLOY_DIR}

# 复制配置文件
cat > ${DEPLOY_DIR}/docker-compose.yml << EOF
version: '3.8'

services:
  app:
    image: chengshang/tools:${VERSION}
    container_name: ${APP_NAME}
    restart: unless-stopped
    environment:
      - DATABASE_URL=${MONGODB_URL}
      - JWT_SECRET=${JWT_SECRET}
      - RUST_LOG=info
    ports:
      - "8080:8080"
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - mongodb
    networks:
      - chengshang-network

  mongodb:
    image: mongo:7
    container_name: chengshang-mongodb
    restart: unless-stopped
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=password123
      - MONGO_INITDB_DATABASE=chengshang_tools
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
      - ./mongodb-init:/docker-entrypoint-initdb.d
    networks:
      - chengshang-network

  nginx:
    image: nginx:alpine
    container_name: chengshang-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    networks:
      - chengshang-network

volumes:
  mongodb_data:

networks:
  chengshang-network:
    driver: bridge
EOF

# 创建Nginx配置
cat > ${DEPLOY_DIR}/nginx.conf << EOF
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:8080;
    }

    server {
        listen 80;
        server_name _;
        
        location / {
            proxy_pass http://app;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
        
        location /ws {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
    }
}
EOF

# 启动服务
cd ${DEPLOY_DIR}
docker-compose up -d

echo "✅ 部署完成!"
echo "📊 应用访问地址: http://localhost"
echo "🗄️  MongoDB访问地址: mongodb://localhost:27017"
echo "📜 查看日志: docker-compose logs -f"
echo "🔧 管理服务: docker-compose [start|stop|restart]"
```

### 3.8 性能优化方案

#### 前端性能优化
- **代码分割**: 使用Next.js的动态导入实现组件懒加载
- **资源优化**: 图片压缩、CSS Tree Shaking、JavaScript混淆
- **缓存策略**: 合理设置HTTP缓存头，使用Service Worker
- **渲染优化**: 虚拟列表、防抖节流、React.memo优化

#### 后端性能优化
- **数据库优化**: 合理的索引设计、查询优化、连接池管理
- **内存管理**: Rust零成本抽象、智能指针使用、内存泄漏检测
- **并发处理**: Tokio异步运行时、连接复用、任务调度优化
- **缓存机制**: Redis缓存热点数据、CDN静态资源分发

### 3.9 测试策略实现

#### 单元测试框架
```rust
// src-tauri/tests/auth_test.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_password_hashing() {
        let password = "test_password_123";
        let hash = AuthService::hash_password(password).unwrap();
        
        assert_ne!(hash, password);
        assert!(hash.starts_with("$argon2"));
    }

    #[tokio::test]
    async fn test_jwt_token_generation() {
        // 测试JWT令牌生成和验证
    }

    #[tokio::test]
    async fn test_login_rate_limiting() {
        // 测试登录频率限制
    }
}
```

#### 集成测试
```typescript
// tests/integration/auth.test.ts
import { invoke } from '@tauri-apps/api/tauri'

describe('Authentication Integration Tests', () => {
  test('should login with valid credentials', async () => {
    const loginRequest = {
      username: 'testuser',
      password: 'testpass123',
      device_info: {
        user_agent: 'test-agent',
        ip_address: '127.0.0.1',
        device_type: 'desktop'
      }
    }

    const response = await invoke('login', { request: loginRequest })
    
    expect(response).toHaveProperty('access_token')
    expect(response).toHaveProperty('refresh_token')
    expect(response).toHaveProperty('user')
  })
})
```

### 3.10 监控与告警系统

#### 系统监控指标
- **性能指标**: CPU、内存、磁盘、网络使用率
- **应用指标**: 响应时间、错误率、并发用户数、工具使用统计
- **业务指标**: 用户活跃度、功能使用频率、错误类型分布

#### 告警规则配置
```rust
pub struct AlertRule {
    pub name: String,
    pub condition: AlertCondition,
    pub threshold: f64,
    pub duration: Duration,
    pub severity: AlertSeverity,
    pub enabled: bool,
}

pub enum AlertSeverity {
    Info,
    Warning,
    Critical,
}

impl AlertRule {
    pub fn cpu_high_usage() -> Self {
        Self {
            name: "CPU使用率过高".to_string(),
            condition: AlertCondition::GreaterThan,
            threshold: 80.0,
            duration: Duration::from_mins(5),
            severity: AlertSeverity::Warning,
            enabled: true,
        }
    }
}
```

## 📈 项目里程碑与开发时间表

### Phase 1: 基础架构重构 (4周)
- **第1周**: 数据库设计与MongoDB集成
- **第2周**: JWT认证系统实现
- **第3周**: Rust后端服务架构搭建
- **第4周**: 基础API接口开发与测试

### Phase 2: 前端开发与集成 (3周)
- **第5周**: React组件重构与登录界面
- **第6周**: 管理后台仪表板开发
- **第7周**: WebSocket实时通信集成

### Phase 3: 系统监控与部署 (3周)
- **第8周**: 系统监控服务实现
- **第9周**: 安全策略与审计日志
- **第10周**: 部署配置与生产环境优化

### Phase 4: 测试与发布 (2周)
- **第11周**: 完整功能测试与性能优化
- **第12周**: 用户验收测试与正式发布

## 🎯 升级版本成功标准

### 技术指标
1. **性能表现**: 登录响应时间<2秒，工具启动时间<3秒
2. **系统稳定性**: 7×24小时稳定运行，故障率<0.1%
3. **安全性**: 通过安全漏洞扫描，符合企业安全标准
4. **扩展性**: 支持100+并发用户，数据库可存储百万级记录

### 业务指标
1. **用户体验**: 用户满意度评分>9.0/10
2. **功能完整性**: 19个工具全部正常运行，新增认证管理功能
3. **管理效率**: 管理员操作效率提升80%，实时监控覆盖率100%
4. **数据洞察**: 提供完整的用户行为分析和系统性能报告

本文档将作为整个项目开发的指导文件，确保开发团队能够按照统一的标准和流程完成高质量的桌面应用开发。