# å‘ˆå°šç­–åˆ’é¡¹ç›®å±•ç¤ºæ¡Œé¢åº”ç”¨å¼€å‘æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

### é¡¹ç›®åç§°
å‘ˆå°šç­–åˆ’é¡¹ç›®å±•ç¤ºæ¡Œé¢åº”ç”¨

### é¡¹ç›®æè¿°
åŸºäºç°æœ‰Next.js UIåŸå‹å›¾ï¼Œä½¿ç”¨Tauriæ¡†æ¶å¼€å‘çš„ä¸“ä¸šçº§æ¡Œé¢åº”ç”¨ï¼Œé›†æˆ19ä¸ªä¸“ä¸šå·¥å…·ï¼ŒæœåŠ¡äºè¿è¥ã€ç¾å·¥ã€é”€å”®ã€äººäº‹ã€å®¢æœç­‰ä¸åŒå²—ä½çš„å·¥ä½œéœ€æ±‚ã€‚

### æ ¸å¿ƒä»·å€¼
- ğŸ¯ **ä¸€ç«™å¼å·¥å…·å¹³å°**ï¼šæ•´åˆ19ä¸ªä¸“ä¸šå·¥å…·ï¼Œæä¾›ç»Ÿä¸€çš„å·¥ä½œå…¥å£
- ğŸš€ **æ¡Œé¢åº”ç”¨ä½“éªŒ**ï¼šåŸç”Ÿæ¡Œé¢æ€§èƒ½ï¼Œç¦»çº¿å¯ç”¨ï¼Œç³»ç»Ÿæ·±åº¦é›†æˆ
- ğŸ¨ **ç°ä»£åŒ–UIè®¾è®¡**ï¼šåŸºäºshadcn/uiçš„ç²¾ç¾ç•Œé¢ï¼Œæ¯›ç»ç’ƒæ•ˆæœå’Œæµç•…åŠ¨ç”»
- ğŸ“Š **æ•°æ®é©±åŠ¨å†³ç­–**ï¼šå®æ—¶ç»Ÿè®¡å’Œåˆ†æåŠŸèƒ½ï¼Œæ”¯æŒä¸šåŠ¡å†³ç­–

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### å‰ç«¯æŠ€æœ¯æ ˆ
```
Frontend (Tauri WebUI)
â”œâ”€â”€ React 18 - å‰ç«¯UIæ¡†æ¶ (æ”¯æŒServer Components)
â”œâ”€â”€ TypeScript - ç±»å‹å®‰å…¨å¼€å‘
â”œâ”€â”€ Next.js 15 (App Router) - å…¨æ ˆæ¡†æ¶é€‚é…Tauri
â”œâ”€â”€ Tailwind CSS - åŸå­åŒ–CSSæ¡†æ¶
â”œâ”€â”€ shadcn/ui - é«˜è´¨é‡ç»„ä»¶åº“
â”œâ”€â”€ Lucide React - ç°ä»£åŒ–å›¾æ ‡åº“
â””â”€â”€ ç‰¹æ®Šæ ·å¼ç‰¹æ€§
    â”œâ”€â”€ backdrop-blur - æ¯›ç»ç’ƒæ•ˆæœ
    â”œâ”€â”€ gradient backgrounds - æ¸å˜èƒŒæ™¯
    â”œâ”€â”€ multi-layer shadows - å¤šå±‚æ¬¡é˜´å½±
    â””â”€â”€ smooth animations - æµç•…åŠ¨ç”»è¿‡æ¸¡
```

### æ¡Œé¢åº”ç”¨æŠ€æœ¯æ ˆ
```
Desktop Application
â”œâ”€â”€ Tauri 2.x - æ¡Œé¢åº”ç”¨æ¡†æ¶
â”œâ”€â”€ Rust - åç«¯æ ¸å¿ƒé€»è¾‘
â”œâ”€â”€ WebView2 - å‰ç«¯æ¸²æŸ“å¼•æ“
â””â”€â”€ ç³»ç»Ÿé›†æˆåŠŸèƒ½
    â”œâ”€â”€ æ–‡ä»¶ç³»ç»Ÿè®¿é—®
    â”œâ”€â”€ ç³»ç»Ÿé€šçŸ¥
    â”œâ”€â”€ åº”ç”¨çª—å£ç®¡ç†
    â””â”€â”€ ç³»ç»Ÿæ‰˜ç›˜é›†æˆ
```

## ğŸ“± åŠŸèƒ½æ¨¡å—æ¶æ„

### æ ¸å¿ƒåŠŸèƒ½åˆ†ç±»

#### 1. è¿è¥ä¸“ç”¨å·¥å…·æ¨¡å— (10ä¸ªå·¥å…·)
```mermaid
graph TD
    A[è¿è¥å·¥å…·æ¨¡å—] --> B[å•†å®¶å›å¤è§£ç­”æ‰‹å†Œ]
    A --> C[å¤–å–è¿è¥çŸ¥è¯†å­¦ä¹ ç³»ç»Ÿ]
    A --> D[å¤–å–åº—é“ºå®Œæ•´è¿è¥æµç¨‹]
    A --> E[å¤–å–å¤–å–è¿è¥çŸ¥è¯†SVGå›¾è¡¨é›†åˆ]
    A --> F[å¤–å–åº—é“ºè¿è¥æ•°æ®å¯è§†åŒ–åŠ¨ç”»æ¼”ç¤ºç³»ç»Ÿ]
    A --> G[åŸŸé”¦ç§‘æŠ€AIç³»ç»Ÿ]
    A --> H[å¾®ä¿¡ç¾¤å‘åŠ©æ‰‹]
    A --> I[è¿è¥äººå‘˜æ¯æ—¥æŠ½ç‚¹åº—é“ºæ•°ç»Ÿè®¡åˆ†æ]
    A --> J[å‘ˆå°šç­–åˆ’è¿è¥æ•°æ®ç³»ç»Ÿ]
    A --> K[å¤–å–åº—é“ºå››ä»¶å¥—æ–¹æ¡ˆç”Ÿæˆç³»ç»Ÿ]
```

#### 2. ç¾å·¥ä¸“ç”¨å·¥å…·æ¨¡å— (2ä¸ªå·¥å…·)
- å¤–å–é—ªè´­äº§å“ä¿¡æ¯å›¾ç‰‡é‡‡é›†è½¯ä»¶
- å¤–å–åº—é“ºæ•°æ®å¤„ç†å·¥å…·

#### 3. é”€å”®ä¸“ç”¨å·¥å…·æ¨¡å— (2ä¸ªå·¥å…·)
- å‘ˆå°šç­–åˆ’é”€å”®éƒ¨æ•°æ®ç»Ÿè®¡ç³»ç»Ÿ
- é”€å”®æ•°æ®æŠ¥å‘Šç”Ÿæˆç³»ç»Ÿ

#### 4. äººäº‹ä¸“ç”¨å·¥å…·æ¨¡å— (4ä¸ªå·¥å…·)
- å‘ˆå°šç­–åˆ’è´¢åŠ¡è®°è´¦ç³»ç»Ÿ
- è¿è¥éƒ¨æ™ºèƒ½æ’ç­ç³»ç»Ÿ+é”€å”®éƒ¨å¤§æ‰«é™¤å®‰æ’è¡¨ç³»ç»Ÿ
- å‘ˆå°šç­–åˆ’äººäº‹é¢è¯•é¡¾é—®ç³»ç»Ÿ
- å‘ˆå°šç­–åˆ’æ•°æ®ç»Ÿè®¡ç³»ç»Ÿ

#### 5. å®¢æœä¸“ç”¨å·¥å…·æ¨¡å— (1ä¸ªå·¥å…·)
- å¤–å–åº—é“ºä¿¡æ¯é‡‡é›†ç³»ç»Ÿ

## ğŸ¨ UI/UX è®¾è®¡è§„èŒƒ

### è®¾è®¡ç³»ç»Ÿ
```typescript
// ä¸»è‰²å½©æ–¹æ¡ˆ
const colorScheme = {
  primary: {
    blue: "from-blue-500 to-blue-600",
    purple: "from-purple-500 to-purple-600",
    gradient: "from-blue-600 to-purple-600"
  },
  category: {
    operations: "from-blue-500 to-blue-600",    // è¿è¥å·¥å…·
    design: "from-purple-500 to-purple-600",    // ç¾å·¥å·¥å…·
    sales: "from-green-500 to-green-600",       // é”€å”®å·¥å…·
    hr: "from-orange-500 to-orange-600",        // äººäº‹å·¥å…·
    service: "from-pink-500 to-pink-600"        // å®¢æœå·¥å…·
  },
  background: {
    main: "bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-50/50",
    card: "bg-white/80 backdrop-blur-sm",
    overlay: "bg-white/95 backdrop-blur-md"
  }
}
```

### ç»„ä»¶è§„èŒƒ
- **å¡ç‰‡ç»„ä»¶**ï¼šåœ†è§’2xlï¼Œæ¯›ç»ç’ƒæ•ˆæœï¼ŒhoveråŠ¨ç”»
- **æŒ‰é’®ç»„ä»¶**ï¼šæ¸å˜èƒŒæ™¯ï¼Œé˜´å½±æ•ˆæœï¼Œç‚¹å‡»åé¦ˆ
- **è¾“å…¥ç»„ä»¶**ï¼šåœ†è§’xlï¼Œèšç„¦çŠ¶æ€å˜åŒ–ï¼Œå¿«æ·é”®æç¤º
- **å›¾æ ‡ç³»ç»Ÿ**ï¼šLucide Reactï¼Œç»Ÿä¸€å°ºå¯¸è§„èŒƒ
- **åŠ¨ç”»æ•ˆæœ**ï¼štransition-all duration-200/300ï¼Œscaleå’Œshadowå˜åŒ–

## ğŸ—‚ï¸ å·¥å…·æ•°æ®ç»“æ„

### å·¥å…·ä¿¡æ¯æ•°æ®æ¨¡å‹
```typescript
interface Tool {
  id: number;
  name: string;
  description: string;
  category: "è¿è¥å·¥å…·" | "ç¾å·¥å·¥å…·" | "é”€å”®å·¥å…·" | "äººäº‹å·¥å…·" | "å®¢æœå·¥å…·";
  url: string;
  icon: LucideIcon;
  rating: number;
  downloads: string;
  tags: string[];
  color: string;
  featured: boolean;
  lastUpdated: string;
  toolType: "web" | "desktop" | "integrated";
  integrationConfig?: {
    embedSupport: boolean;
    apiEndpoint?: string;
    authRequired: boolean;
  };
}
```

### å®Œæ•´å·¥å…·æ¸…å•æ•°æ®
```typescript
const toolsData: Tool[] = [
  {
    id: 1,
    name: "å•†å®¶å›å¤è§£ç­”æ‰‹å†Œ",
    description: "æä¾›æ ‡å‡†åŒ–çš„å®¢æˆ·åé¦ˆå¤„ç†æ¨¡æ¿å’Œæ²Ÿé€šæŠ€å·§",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/shangjiahuizong/",
    icon: MessageSquare,
    rating: 4.8,
    downloads: "2.1k",
    tags: ["å›å¤æ¨¡æ¿", "æ²Ÿé€šæŠ€å·§", "å®¢æˆ·åé¦ˆ"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "2å¤©å‰",
    toolType: "web"
  },
  {
    id: 2,
    name: "å¤–å–è¿è¥çŸ¥è¯†å­¦ä¹ ç³»ç»Ÿ",
    description: "ç³»ç»ŸåŒ–çš„è¿è¥çŸ¥è¯†å­¦ä¹ å’Œè€ƒè¯•å¹³å°",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/kaoshixitong/index.html",
    icon: BookOpen,
    rating: 4.7,
    downloads: "1.8k",
    tags: ["çŸ¥è¯†åº“", "åœ¨çº¿è€ƒè¯•", "å­¦ä¹ è¿½è¸ª"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "3å¤©å‰",
    toolType: "web"
  },
  {
    id: 3,
    name: "å¤–å–åº—é“ºå®Œæ•´è¿è¥æµç¨‹",
    description: "è¯¦ç»†çš„åº—é“ºè¿è¥æµç¨‹æŒ‡å—å’Œæ“ä½œæ‰‹å†Œ",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/meituanyunyingliucheng/",
    icon: Workflow,
    rating: 4.9,
    downloads: "2.5k",
    tags: ["æµç¨‹å¯è§†åŒ–", "æ“ä½œæ‰‹å†Œ", "æœ€ä½³å®è·µ"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "1å¤©å‰",
    toolType: "web"
  },
  {
    id: 4,
    name: "å¤–å–å¤–å–è¿è¥çŸ¥è¯†SVGå›¾è¡¨é›†åˆ",
    description: "è¿è¥çŸ¥è¯†çš„å¯è§†åŒ–å›¾è¡¨å±•ç¤º",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/meituan-svg-guide-new/",
    icon: BarChart3,
    rating: 4.6,
    downloads: "1.3k",
    tags: ["SVGå›¾è¡¨", "äº¤äº’å±•ç¤º", "çŸ¥è¯†å…³è”"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "4å¤©å‰",
    toolType: "web"
  },
  {
    id: 5,
    name: "å¤–å–åº—é“ºè¿è¥æ•°æ®å¯è§†åŒ–åŠ¨ç”»æ¼”ç¤ºç³»ç»Ÿ",
    description: "åŠ¨æ€å±•ç¤ºåº—é“ºè¿è¥æ•°æ®å’Œè¶‹åŠ¿åˆ†æ",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/meituanshujuyanshi/",
    icon: TrendingUp,
    rating: 4.8,
    downloads: "2.2k",
    tags: ["æ•°æ®å¯è§†åŒ–", "è¶‹åŠ¿åˆ†æ", "åŠ¨ç”»æ¼”ç¤º"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "2å¤©å‰",
    toolType: "web"
  },
  {
    id: 6,
    name: "åŸŸé”¦ç§‘æŠ€AIç³»ç»Ÿ",
    description: "åŸºäºAIæŠ€æœ¯çš„æ™ºèƒ½åŠ©æ‰‹å¹³å°",
    category: "è¿è¥å·¥å…·",
    url: "https://www.yujinkeji.me",
    icon: Bot,
    rating: 4.9,
    downloads: "3.1k",
    tags: ["AIåŠ©æ‰‹", "æ™ºèƒ½é—®ç­”", "æ€ç»´å¯¼å›¾"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "1å¤©å‰",
    toolType: "web"
  },
  {
    id: 7,
    name: "å¾®ä¿¡ç¾¤å‘åŠ©æ‰‹",
    description: "æ‰¹é‡å‘é€å¾®ä¿¡æ¶ˆæ¯çš„æ¡Œé¢åº”ç”¨",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/weixin/",
    icon: MessageCircle,
    rating: 4.5,
    downloads: "1.9k",
    tags: ["æ‰¹é‡å‘é€", "å®‰å…¨å¯é ", "æ¨¡æ‹Ÿæ“ä½œ"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "5å¤©å‰",
    toolType: "desktop"
  },
  {
    id: 8,
    name: "è¿è¥äººå‘˜æ¯æ—¥æŠ½ç‚¹åº—é“ºæ•°ç»Ÿè®¡åˆ†æ",
    description: "è¿è¥äººå‘˜å·¥ä½œé‡ç»Ÿè®¡å’Œç»©æ•ˆåˆ†æ",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/yunyingshujutongji/",
    icon: Target,
    rating: 4.7,
    downloads: "1.6k",
    tags: ["å·¥ä½œé‡è¿½è¸ª", "è¶‹åŠ¿å¯¹æ¯”", "ç»©æ•ˆè¯„ä¼°"],
    color: "from-blue-500 to-blue-600",
    featured: false,
    lastUpdated: "3å¤©å‰",
    toolType: "web"
  },
  {
    id: 9,
    name: "å‘ˆå°šç­–åˆ’è¿è¥æ•°æ®ç³»ç»Ÿ",
    description: "ç»¼åˆè¿è¥æ•°æ®ç®¡ç†å’Œåˆ†æç³»ç»Ÿ",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/feishudianputongji/",
    icon: Database,
    rating: 4.8,
    downloads: "2.4k",
    tags: ["æ•°æ®ç»Ÿè®¡", "è§£çº¦æŸ¥è¯¢", "è¿è¥åˆ†æ"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "2å¤©å‰",
    toolType: "web"
  },
  {
    id: 10,
    name: "å¤–å–åº—é“ºå››ä»¶å¥—æ–¹æ¡ˆç”Ÿæˆç³»ç»Ÿ",
    description: "åŸºäºAIçš„åº—é“ºè¿è¥æ–¹æ¡ˆè‡ªåŠ¨ç”Ÿæˆ",
    category: "è¿è¥å·¥å…·",
    url: "https://xuxikai886.github.io/sijiantaofanganshengcheng/",
    icon: Sparkles,
    rating: 4.9,
    downloads: "2.8k",
    tags: ["AIæ™ºèƒ½åˆ†æ", "å“ç‰Œå®šä½", "å•†åœˆè°ƒç ”"],
    color: "from-blue-500 to-blue-600",
    featured: true,
    lastUpdated: "1å¤©å‰",
    toolType: "web"
  },
  // ç¾å·¥å·¥å…·
  {
    id: 11,
    name: "å¤–å–é—ªè´­äº§å“ä¿¡æ¯å›¾ç‰‡é‡‡é›†è½¯ä»¶",
    description: "è‡ªåŠ¨é‡‡é›†äº§å“ä¿¡æ¯å’Œå›¾ç‰‡èµ„æº",
    category: "ç¾å·¥å·¥å…·",
    url: "https://xuxikai886.github.io/shangou-caiji/",
    icon: ImageIcon,
    rating: 4.6,
    downloads: "1.4k",
    tags: ["æ‰¹é‡é‡‡é›†", "å›¾ç‰‡å¤„ç†", "æ•°æ®å¯¼å‡º"],
    color: "from-purple-500 to-purple-600",
    featured: false,
    lastUpdated: "4å¤©å‰",
    toolType: "web"
  },
  {
    id: 12,
    name: "å¤–å–åº—é“ºæ•°æ®å¤„ç†å·¥å…·",
    description: "åº—é“ºå›¾ç‰‡å’Œäº§å“æ•°æ®çš„æ‰¹é‡å¤„ç†",
    category: "ç¾å·¥å·¥å…·",
    url: "https://xuxikai886.github.io/meituanshangpingtupianxiazai/",
    icon: Edit,
    rating: 4.7,
    downloads: "1.7k",
    tags: ["æ•°æ®æå–", "å›¾ç‰‡ä¼˜åŒ–", "Fluentè®¾è®¡"],
    color: "from-purple-500 to-purple-600",
    featured: false,
    lastUpdated: "3å¤©å‰",
    toolType: "web"
  },
  // é”€å”®å·¥å…·
  {
    id: 13,
    name: "å‘ˆå°šç­–åˆ’é”€å”®éƒ¨æ•°æ®ç»Ÿè®¡ç³»ç»Ÿ",
    description: "é”€å”®æ•°æ®å®æ—¶ç»Ÿè®¡å’Œåˆ†æ",
    category: "é”€å”®å·¥å…·",
    url: "https://www.chengshangcehua.top/",
    icon: ShoppingCart,
    rating: 4.8,
    downloads: "2.3k",
    tags: ["å®æ—¶æ•°æ®", "ç›®æ ‡è¿½è¸ª", "ç»©æ•ˆåˆ†æ"],
    color: "from-green-500 to-green-600",
    featured: true,
    lastUpdated: "1å¤©å‰",
    toolType: "web"
  },
  {
    id: 14,
    name: "é”€å”®æ•°æ®æŠ¥å‘Šç”Ÿæˆç³»ç»Ÿ",
    description: "20ç§’å¿«é€Ÿç”Ÿæˆä¸“ä¸šé”€å”®æŠ¥å‘Š",
    category: "é”€å”®å·¥å…·",
    url: "https://xuxikai886.github.io/xiaoshoushujubaogao/",
    icon: FileText,
    rating: 4.9,
    downloads: "2.6k",
    tags: ["ä¸€é”®ç”Ÿæˆ", "ä¸“ä¸šæ¨¡æ¿", "å¿«é€Ÿå¯¼å‡º"],
    color: "from-green-500 to-green-600",
    featured: true,
    lastUpdated: "2å¤©å‰",
    toolType: "web"
  },
  // äººäº‹å·¥å…·
  {
    id: 15,
    name: "å‘ˆå°šç­–åˆ’è´¢åŠ¡è®°è´¦ç³»ç»Ÿ",
    description: "ä¼ä¸šè´¢åŠ¡æ”¶æ”¯è®°å½•å’Œç»Ÿè®¡",
    category: "äººäº‹å·¥å…·",
    url: "https://www.yujinkeji.net/login",
    icon: Calculator,
    rating: 4.7,
    downloads: "1.8k",
    tags: ["æ”¶æ”¯è®°å½•", "å‡­è¯ç®¡ç†", "è´¢åŠ¡æŠ¥è¡¨"],
    color: "from-orange-500 to-orange-600",
    featured: false,
    lastUpdated: "3å¤©å‰",
    toolType: "web"
  },
  {
    id: 16,
    name: "è¿è¥éƒ¨æ™ºèƒ½æ’ç­ç³»ç»Ÿ+é”€å”®éƒ¨å¤§æ‰«é™¤å®‰æ’è¡¨ç³»ç»Ÿ",
    description: "æ™ºèƒ½æ’ç­å’Œä»»åŠ¡åˆ†é…ç³»ç»Ÿ",
    category: "äººäº‹å·¥å…·",
    url: "https://xuxikai886.github.io/cschpaibanxitong/index.html",
    icon: Calendar,
    rating: 4.6,
    downloads: "1.5k",
    tags: ["éšæœºæ’ç­", "å…¬å¹³åˆ†é…", "ä»»åŠ¡ç®¡ç†"],
    color: "from-orange-500 to-orange-600",
    featured: false,
    lastUpdated: "4å¤©å‰",
    toolType: "web"
  },
  {
    id: 17,
    name: "å‘ˆå°šç­–åˆ’äººäº‹é¢è¯•é¡¾é—®ç³»ç»Ÿ",
    description: "ç®€å†åˆ†æå’Œé¢è¯•æŒ‡å—ç”Ÿæˆ",
    category: "äººäº‹å·¥å…·",
    url: "https://xuxikai886.github.io/renshimianshixitong/",
    icon: UserCheck,
    rating: 4.8,
    downloads: "2.1k",
    tags: ["ç®€å†è§£æ", "é¢è¯•é¢˜åº“", "è¯„ä¼°æŠ¥å‘Š"],
    color: "from-orange-500 to-orange-600",
    featured: true,
    lastUpdated: "2å¤©å‰",
    toolType: "web"
  },
  {
    id: 18,
    name: "å‘ˆå°šç­–åˆ’æ•°æ®ç»Ÿè®¡ç³»ç»Ÿ",
    description: "ä¼ä¸šç»¼åˆæ•°æ®ç»Ÿè®¡å’Œåˆ†æ",
    category: "äººäº‹å·¥å…·",
    url: "https://xuxikai886.github.io/chengshangcehshujutongji/",
    icon: PieChart,
    rating: 4.7,
    downloads: "1.9k",
    tags: ["å¤šç»´åº¦ç»Ÿè®¡", "è¶‹åŠ¿åˆ†æ", "æŠ¥è¡¨ç”Ÿæˆ"],
    color: "from-orange-500 to-orange-600",
    featured: false,
    lastUpdated: "3å¤©å‰",
    toolType: "web"
  },
  // å®¢æœå·¥å…·
  {
    id: 19,
    name: "å¤–å–åº—é“ºä¿¡æ¯é‡‡é›†ç³»ç»Ÿ",
    description: "æ‰¹é‡é‡‡é›†å¤–å–åº—é“ºåŸºç¡€ä¿¡æ¯",
    category: "å®¢æœå·¥å…·",
    url: "https://xuxikai886.github.io/meituandianpuxinxicaiji/",
    icon: Search,
    rating: 4.9,
    downloads: "3.2k",
    tags: ["è‡ªåŠ¨è§£æ", "æ‰¹é‡å¤„ç†", "Excelå¯¼å‡º"],
    color: "from-pink-500 to-pink-600",
    featured: true,
    lastUpdated: "1å¤©å‰",
    toolType: "web"
  }
];
```

## ğŸ”§ æŠ€æœ¯å®æ–½æ–¹æ¡ˆ

### 1. Tauriåº”ç”¨åˆå§‹åŒ–
```bash
# åˆ›å»ºTaurié¡¹ç›®
npm create tauri-app@latest
cd tauri-app

# é…ç½®Tauri
# ä¿®æ”¹ src-tauri/tauri.conf.json
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devPath": "http://localhost:3000",
    "distDir": "../out"
  },
  "package": {
    "productName": "å‘ˆå°šç­–åˆ’é¡¹ç›®å±•ç¤º",
    "version": "1.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      },
      "window": {
        "all": false,
        "close": true,
        "hide": true,
        "show": true,
        "maximize": true,
        "minimize": true,
        "unmaximize": true,
        "unminimize": true,
        "startDragging": true
      }
    }
  }
}
```

### 2. Next.jsé€‚é…Taurié…ç½®
```javascript
// next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  trailingSlash: true,
  images: {
    unoptimized: true
  },
  assetPrefix: process.env.NODE_ENV === 'production' ? './' : undefined,
}

export default nextConfig
```

### 3. å·¥å…·é›†æˆç­–ç•¥

#### Webå·¥å…·é›†æˆæ–¹å¼
```typescript
// utils/toolLauncher.ts
import { open } from '@tauri-apps/api/shell';

export class ToolLauncher {
  static async openWebTool(url: string) {
    try {
      await open(url);
    } catch (error) {
      console.error('Failed to open tool:', error);
      // é™çº§åˆ°å†…ç½®webview
      this.openInternalWebview(url);
    }
  }

  static openInternalWebview(url: string) {
    // åœ¨åº”ç”¨å†…éƒ¨æ‰“å¼€webview
    // å®ç°å·¥å…·çš„åµŒå…¥å¼å±•ç¤º
  }
}
```

#### æ¡Œé¢å·¥å…·é›†æˆæ–¹å¼
```typescript
// å¯¹äºéœ€è¦æ¡Œé¢é›†æˆçš„å·¥å…·ï¼ˆå¦‚å¾®ä¿¡ç¾¤å‘åŠ©æ‰‹ï¼‰
// é€šè¿‡Ruståç«¯å®ç°æ ¸å¿ƒåŠŸèƒ½
#[tauri::command]
async fn send_wechat_messages(messages: Vec<String>) -> Result<String, String> {
    // Rustå®ç°å¾®ä¿¡ç¾¤å‘é€»è¾‘
    Ok("Messages sent successfully".to_string())
}
```

### 4. æ•°æ®ç®¡ç†æ–¹æ¡ˆ

#### æœ¬åœ°æ•°æ®å­˜å‚¨
```typescript
// utils/storage.ts
import { Store } from '@tauri-apps/plugin-store';

export class DataManager {
  private store: Store;

  constructor() {
    this.store = new Store('.settings.dat');
  }

  async saveUserPreferences(preferences: UserPreferences) {
    await this.store.set('user_preferences', preferences);
    await this.store.save();
  }

  async getToolUsageStats(): Promise<ToolUsageStats> {
    return await this.store.get('usage_stats') || {};
  }

  async updateToolUsage(toolId: number) {
    const stats = await this.getToolUsageStats();
    stats[toolId] = (stats[toolId] || 0) + 1;
    await this.store.set('usage_stats', stats);
    await this.store.save();
  }
}
```

### 5. ç³»ç»Ÿé›†æˆåŠŸèƒ½

#### ç³»ç»Ÿæ‰˜ç›˜é›†æˆ
```rust
// src-tauri/src/main.rs
use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu, SystemTrayEvent};

fn main() {
    let quit = CustomMenuItem::new("quit".to_string(), "é€€å‡º");
    let show = CustomMenuItem::new("show".to_string(), "æ˜¾ç¤ºçª—å£");
    let tray_menu = SystemTrayMenu::new()
        .add_item(show)
        .add_native_item(SystemTrayMenuItem::Separator)
        .add_item(quit);

    let system_tray = SystemTray::new().with_menu(tray_menu);

    tauri::Builder::default()
        .system_tray(system_tray)
        .on_system_tray_event(|app, event| match event {
            SystemTrayEvent::LeftClick { .. } => {
                let window = app.get_window("main").unwrap();
                window.show().unwrap();
                window.set_focus().unwrap();
            }
            SystemTrayEvent::MenuItemClick { id, .. } => {
                match id.as_str() {
                    "quit" => std::process::exit(0),
                    "show" => {
                        let window = app.get_window("main").unwrap();
                        window.show().unwrap();
                    }
                    _ => {}
                }
            }
            _ => {}
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

## ğŸ“Š å¼€å‘å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šåŸºç¡€æ¶æ„æ­å»º (ç¬¬1-2å‘¨)
- [x] åˆ†æç°æœ‰UIåŸå‹å›¾ä»£ç 
- [ ] æ­å»ºTaurié¡¹ç›®åŸºç¡€æ¶æ„
- [ ] é…ç½®Next.jsé€‚é…Tauriçš„æ„å»ºæµç¨‹
- [ ] è¿ç§»ç°æœ‰UIç»„ä»¶åˆ°Tauriç¯å¢ƒ
- [ ] å®ç°åŸºç¡€çª—å£ç®¡ç†åŠŸèƒ½

### é˜¶æ®µäºŒï¼šæ ¸å¿ƒåŠŸèƒ½å¼€å‘ (ç¬¬3-5å‘¨)
- [ ] å®ç°å·¥å…·åˆ†ç±»å’Œå±•ç¤ºåŠŸèƒ½
- [ ] å¼€å‘å·¥å…·å¯åŠ¨å’Œç®¡ç†æœºåˆ¶
- [ ] é›†æˆ19ä¸ªå·¥å…·çš„åŸºç¡€è®¿é—®åŠŸèƒ½
- [ ] å®ç°æ•°æ®ç»Ÿè®¡å’Œä½¿ç”¨åˆ†æ
- [ ] å¼€å‘ç”¨æˆ·åå¥½è®¾ç½®åŠŸèƒ½

### é˜¶æ®µä¸‰ï¼šé«˜çº§åŠŸèƒ½å®ç° (ç¬¬6-7å‘¨)
- [ ] å®ç°ç³»ç»Ÿæ‰˜ç›˜é›†æˆ
- [ ] å¼€å‘ç¦»çº¿åŠŸèƒ½æ”¯æŒ
- [ ] å®ç°å·¥å…·æ”¶è—å’Œæœ€è¿‘ä½¿ç”¨åŠŸèƒ½
- [ ] é›†æˆç³»ç»Ÿé€šçŸ¥åŠŸèƒ½
- [ ] å¼€å‘å¿«æ·é”®æ”¯æŒ

### é˜¶æ®µå››ï¼šä¼˜åŒ–å’Œæµ‹è¯• (ç¬¬8å‘¨)
- [ ] æ€§èƒ½ä¼˜åŒ–å’Œå†…å­˜ç®¡ç†
- [ ] è·¨å¹³å°å…¼å®¹æ€§æµ‹è¯•
- [ ] ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- [ ] å®‰å…¨æ€§æ£€æŸ¥å’ŒåŠ å›º
- [ ] è‡ªåŠ¨æ›´æ–°æœºåˆ¶å®ç°

## ğŸ“ é¡¹ç›®æ–‡ä»¶ç»“æ„

```
å‘ˆå°šç­–åˆ’æ¡Œé¢åº”ç”¨/
â”œâ”€â”€ src-tauri/                 # Tauriåç«¯ä»£ç 
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs           # ä¸»ç¨‹åºå…¥å£
â”‚   â”‚   â”œâ”€â”€ commands.rs       # Tauriå‘½ä»¤å®ç°
â”‚   â”‚   â””â”€â”€ utils.rs          # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ Cargo.toml            # Rustä¾èµ–é…ç½®
â”‚   â””â”€â”€ tauri.conf.json       # Taurié…ç½®æ–‡ä»¶
â”œâ”€â”€ app/                      # Next.jsåº”ç”¨ç›®å½•
â”‚   â”œâ”€â”€ layout.tsx            # æ ¹å¸ƒå±€ç»„ä»¶
â”‚   â”œâ”€â”€ page.tsx              # ä¸»é¡µé¢ç»„ä»¶
â”‚   â””â”€â”€ globals.css           # å…¨å±€æ ·å¼
â”œâ”€â”€ components/               # Reactç»„ä»¶ç›®å½•
â”‚   â”œâ”€â”€ ui/                   # shadcn/uiç»„ä»¶
â”‚   â”œâ”€â”€ header.tsx            # å¤´éƒ¨ç»„ä»¶
â”‚   â”œâ”€â”€ sidebar.tsx           # ä¾§è¾¹æ ç»„ä»¶
â”‚   â”œâ”€â”€ tool-grid.tsx         # å·¥å…·ç½‘æ ¼ç»„ä»¶
â”‚   â”œâ”€â”€ stats-cards.tsx       # ç»Ÿè®¡å¡ç‰‡ç»„ä»¶
â”‚   â””â”€â”€ tool-launcher.tsx     # å·¥å…·å¯åŠ¨ç»„ä»¶
â”œâ”€â”€ lib/                      # å·¥å…·åº“ç›®å½•
â”‚   â”œâ”€â”€ utils.ts              # é€šç”¨å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ tool-data.ts          # å·¥å…·æ•°æ®é…ç½®
â”‚   â””â”€â”€ storage.ts            # æ•°æ®å­˜å‚¨ç®¡ç†
â”œâ”€â”€ hooks/                    # React Hooks
â”‚   â”œâ”€â”€ use-tools.ts          # å·¥å…·ç®¡ç†Hook
â”‚   â””â”€â”€ use-storage.ts        # å­˜å‚¨ç®¡ç†Hook
â”œâ”€â”€ types/                    # TypeScriptç±»å‹å®šä¹‰
â”‚   â””â”€â”€ tools.ts              # å·¥å…·ç›¸å…³ç±»å‹
â””â”€â”€ public/                   # é™æ€èµ„æº
    â”œâ”€â”€ icons/                # åº”ç”¨å›¾æ ‡
    â””â”€â”€ assets/               # å…¶ä»–é™æ€èµ„æº
```

## ğŸ” å®‰å…¨æ€§è€ƒè™‘

### æ•°æ®å®‰å…¨
- æœ¬åœ°æ•°æ®åŠ å¯†å­˜å‚¨
- ç”¨æˆ·æ•æ„Ÿä¿¡æ¯ä¿æŠ¤
- å®‰å…¨çš„å¤–éƒ¨å·¥å…·è®¿é—®æœºåˆ¶

### åº”ç”¨å®‰å…¨
- CSPå†…å®¹å®‰å…¨ç­–ç•¥é…ç½®
- å¤–éƒ¨é“¾æ¥å®‰å…¨éªŒè¯
- æ¶æ„ä»£ç é˜²æŠ¤æœºåˆ¶

### æ›´æ–°å®‰å…¨
- æ•°å­—ç­¾åéªŒè¯
- å®‰å…¨çš„è‡ªåŠ¨æ›´æ–°æœºåˆ¶
- ç‰ˆæœ¬å›æ»šä¿æŠ¤

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å‰ç«¯ä¼˜åŒ–
- Reactç»„ä»¶æ‡’åŠ è½½
- å›¾ç‰‡èµ„æºä¼˜åŒ–
- CSSæ ·å¼ä¼˜åŒ–
- åŠ¨ç”»æ€§èƒ½ä¼˜åŒ–

### åç«¯ä¼˜åŒ–
- Rustä»£ç æ€§èƒ½ä¼˜åŒ–
- å†…å­˜ä½¿ç”¨ä¼˜åŒ–
- æ–‡ä»¶ç³»ç»Ÿè®¿é—®ä¼˜åŒ–
- å¹¶å‘å¤„ç†ä¼˜åŒ–

### åº”ç”¨ä¼˜åŒ–
- å¯åŠ¨æ—¶é—´ä¼˜åŒ–
- çª—å£æ¸²æŸ“ä¼˜åŒ–
- èµ„æºé¢„åŠ è½½ç­–ç•¥
- ç¼“å­˜æœºåˆ¶å®ç°

## ğŸš€ éƒ¨ç½²å’Œåˆ†å‘

### æ„å»ºé…ç½®
```bash
# å¼€å‘ç¯å¢ƒè¿è¡Œ
npm run tauri dev

# ç”Ÿäº§ç¯å¢ƒæ„å»º
npm run tauri build
```

### åˆ†å‘ç­–ç•¥
- Windows: .msiå®‰è£…åŒ…
- macOS: .dmgç£ç›˜æ˜ åƒ
- Linux: .deb/.rpmåŒ…
- è‡ªåŠ¨æ›´æ–°æœåŠ¡å™¨é…ç½®

## ğŸ“š å¼€å‘è§„èŒƒ

### ä»£ç è§„èŒƒ
- TypeScriptä¸¥æ ¼æ¨¡å¼
- ESLintä»£ç æ£€æŸ¥
- Prettierä»£ç æ ¼å¼åŒ–
- Gitæäº¤è§„èŒƒ

### ç»„ä»¶å¼€å‘è§„èŒƒ
- éµå¾ªshadcn/uiè®¾è®¡ç³»ç»Ÿ
- å“åº”å¼è®¾è®¡é€‚é…
- æ— éšœç¢æ€§æ”¯æŒ
- æ€§èƒ½ç›‘æ§é›†æˆ

### æµ‹è¯•ç­–ç•¥
- å•å…ƒæµ‹è¯•è¦†ç›–
- é›†æˆæµ‹è¯•éªŒè¯
- ç«¯åˆ°ç«¯æµ‹è¯•ä¿éšœ
- æ€§èƒ½æµ‹è¯•ç›‘æ§

## ğŸ“ æŠ€æœ¯æ”¯æŒå’Œç»´æŠ¤

### ç‰ˆæœ¬ç®¡ç†
- è¯­ä¹‰åŒ–ç‰ˆæœ¬æ§åˆ¶
- å˜æ›´æ—¥å¿—ç»´æŠ¤
- å…¼å®¹æ€§ä¿è¯ç­–ç•¥

### ç”¨æˆ·åé¦ˆ
- é”™è¯¯æŠ¥å‘Šæ”¶é›†
- ç”¨æˆ·ä½¿ç”¨åˆ†æ
- åŠŸèƒ½è¯·æ±‚ç®¡ç†
- æŠ€æœ¯æ”¯æŒä½“ç³»

---

## ğŸ¯ é¡¹ç›®æˆåŠŸæ ‡å‡†

1. **åŠŸèƒ½å®Œæ•´æ€§**ï¼š19ä¸ªå·¥å…·å…¨éƒ¨é›†æˆå¹¶æ­£å¸¸å·¥ä½œ
2. **ç”¨æˆ·ä½“éªŒ**ï¼šæµç•…çš„ç•Œé¢äº¤äº’å’Œç›´è§‚çš„æ“ä½œæµç¨‹
3. **æ€§èƒ½è¡¨ç°**ï¼šå¿«é€Ÿå¯åŠ¨ã€ä½å†…å­˜å ç”¨ã€ç¨³å®šè¿è¡Œ
4. **è·¨å¹³å°å…¼å®¹**ï¼šWindowsã€macOSã€Linuxä¸‰å¹³å°æ”¯æŒ
5. **å®‰å…¨å¯é **ï¼šæ•°æ®å®‰å…¨ä¿æŠ¤å’Œç¨³å®šçš„ç³»ç»Ÿé›†æˆ

---

## ğŸ”„ å‡çº§ç‰ˆç³»ç»Ÿæ¶æ„è®¾è®¡

### æ–°å¢æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

#### 1. ç”¨æˆ·è®¤è¯ä¸æƒé™ç®¡ç†ç³»ç»Ÿ
```mermaid
graph TB
    A[ç”¨æˆ·ç™»å½•] --> B[JWTè®¤è¯æœåŠ¡]
    B --> C[åŒä»¤ç‰Œæœºåˆ¶]
    C --> D[Access Token<br/>15åˆ†é’Ÿæœ‰æ•ˆæœŸ]
    C --> E[Refresh Token<br/>7å¤©æœ‰æ•ˆæœŸ]
    B --> F[æƒé™éªŒè¯ä¸­é—´ä»¶]
    F --> G[è§’è‰²æƒé™æ§åˆ¶]
    G --> H[åŠŸèƒ½æ¨¡å—è®¿é—®æ§åˆ¶]
    
    I[MongoDBç”¨æˆ·æ•°æ®åº“] --> J[ç”¨æˆ·ä¿¡æ¯å­˜å‚¨]
    I --> K[ä¼šè¯ç®¡ç†]
    I --> L[æ“ä½œæ—¥å¿—è®°å½•]
```

#### 2. å®æ—¶ç›‘æ§ä¸æ•°æ®åˆ†æç³»ç»Ÿ
```mermaid
graph TB
    A[å‰ç«¯åŸ‹ç‚¹æ•°æ®æ”¶é›†] --> B[WebSocketå®æ—¶é€šä¿¡]
    B --> C[æ•°æ®é¢„å¤„ç†æœåŠ¡]
    C --> D[MongoDBæ•°æ®å­˜å‚¨]
    D --> E[æ•°æ®èšåˆåˆ†æ]
    E --> F[å®æ—¶ä»ªè¡¨æ¿]
    E --> G[ç»Ÿè®¡æŠ¥è¡¨ç”Ÿæˆ]
    
    H[ç³»ç»Ÿæ€§èƒ½ç›‘æ§] --> I[CPU/å†…å­˜/ç½‘ç»œ]
    I --> J[å‘Šè­¦æœºåˆ¶]
    J --> K[ç®¡ç†å‘˜é€šçŸ¥]
```

### æŠ€æœ¯æ¶æ„å‡çº§æ–¹æ¡ˆ

#### åç«¯æŠ€æœ¯æ ˆå‡çº§
```toml
# src-tauri/Cargo.toml æ–°å¢ä¾èµ–
[dependencies]
# æ ¸å¿ƒæ¡†æ¶
tauri = { version = "2.0", features = ["api-all"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }

# è®¤è¯ä¸å®‰å…¨
jsonwebtoken = "9.2.0"
argon2 = "0.5.3"
uuid = { version = "1.6.1", features = ["v4"] }
chrono = { version = "0.4.31", features = ["serde"] }

# æ•°æ®åº“é›†æˆ
mongodb = "2.8.2"
bson = "2.9.0"

# ç½‘ç»œé€šä¿¡
reqwest = { version = "0.12.5", features = ["json", "rustls-tls"] }
tungstenite = "0.21.0"
tokio-tungstenite = "0.21.0"

# åŠ å¯†ä¸å‹ç¼©
aes-gcm = "0.10.3"
base64 = "0.22.1"
flate2 = "1.0.28"

# æ—¥å¿—ä¸é”™è¯¯å¤„ç†
tracing = "0.1.40"
tracing-subscriber = "0.3.18"
anyhow = "1.0.79"
thiserror = "1.0.56"

# é…ç½®ç®¡ç†
config = "0.14.0"
```

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡ä¸æ¶æ„

### MongoDB é›†åˆè®¾è®¡

#### ç”¨æˆ·ç®¡ç†é›†åˆ
```javascript
// users é›†åˆ
{
  _id: ObjectId,
  username: String,        // ç”¨æˆ·åï¼ˆå”¯ä¸€ï¼‰
  email: String,           // é‚®ç®±ï¼ˆå”¯ä¸€ï¼‰
  password_hash: String,   // Argon2å“ˆå¸Œå¯†ç 
  role: String,            // ç”¨æˆ·è§’è‰²: admin, operator, viewer
  permissions: [String],   // æƒé™åˆ—è¡¨
  profile: {
    display_name: String,
    avatar_url: String,
    department: String,    // éƒ¨é—¨ï¼šè¿è¥ã€ç¾å·¥ã€é”€å”®ã€äººäº‹ã€å®¢æœ
    position: String
  },
  settings: {
    theme: String,         // ä¸»é¢˜åå¥½
    language: String,      // è¯­è¨€è®¾ç½®
    notifications: Boolean
  },
  status: String,          // active, inactive, suspended
  last_login: Date,
  created_at: Date,
  updated_at: Date
}

// user_sessions é›†åˆ
{
  _id: ObjectId,
  user_id: ObjectId,
  refresh_token: String,   // åŠ å¯†å­˜å‚¨çš„åˆ·æ–°ä»¤ç‰Œ
  access_token_jti: String, // JWT ID
  device_info: {
    user_agent: String,
    ip_address: String,
    device_type: String
  },
  expires_at: Date,
  created_at: Date,
  is_revoked: Boolean
}
```

#### ç³»ç»Ÿç›‘æ§é›†åˆ
```javascript
// system_metrics é›†åˆ
{
  _id: ObjectId,
  timestamp: Date,
  metrics: {
    cpu_usage: Number,     // CPUä½¿ç”¨ç‡
    memory_usage: Number,  // å†…å­˜ä½¿ç”¨ç‡
    disk_usage: Number,    // ç£ç›˜ä½¿ç”¨ç‡
    network_io: {
      bytes_sent: Number,
      bytes_received: Number
    }
  },
  application_metrics: {
    active_users: Number,
    concurrent_sessions: Number,
    tool_usage_count: Number,
    error_count: Number
  }
}

// user_activities é›†åˆ
{
  _id: ObjectId,
  user_id: ObjectId,
  activity_type: String,   // login, logout, tool_access, admin_action
  tool_id: Number,         // å·¥å…·IDï¼ˆå¦‚æœæ˜¯å·¥å…·è®¿é—®ï¼‰
  details: {
    tool_name: String,
    duration: Number,      // ä½¿ç”¨æ—¶é•¿ï¼ˆç§’ï¼‰
    success: Boolean,
    error_message: String
  },
  metadata: {
    ip_address: String,
    user_agent: String,
    session_id: String
  },
  timestamp: Date
}

// audit_logs é›†åˆ
{
  _id: ObjectId,
  user_id: ObjectId,
  action: String,          // CREATE, READ, UPDATE, DELETE, LOGIN, LOGOUT
  resource: String,        // æ“ä½œçš„èµ„æºç±»å‹
  resource_id: String,     // èµ„æºID
  old_values: Object,      // ä¿®æ”¹å‰çš„å€¼
  new_values: Object,      // ä¿®æ”¹åçš„å€¼
  ip_address: String,
  user_agent: String,
  success: Boolean,
  error_message: String,
  timestamp: Date
}
```

## ğŸ” è¯¦ç»†æŠ€æœ¯å®ç°æ–¹æ¡ˆ

### Phase 1: Rust åç«¯æœåŠ¡æ¶æ„é‡æ„

#### 1.1 ä¸»åº”ç”¨æ¶æ„ (src-tauri/src/main.rs)
```rust
use tauri::{generate_context, generate_handler, Builder, Manager, WindowEvent};
use std::sync::Arc;
use tokio::sync::Mutex;

mod config;
mod database;
mod auth;
mod websocket;
mod monitoring;
mod services;
mod utils;
mod error;

use config::AppConfig;
use database::DatabaseService;
use auth::AuthService;
use websocket::WebSocketService;
use monitoring::MonitoringService;

pub struct AppState {
    pub config: Arc<AppConfig>,
    pub db: Arc<DatabaseService>,
    pub auth: Arc<AuthService>,
    pub websocket: Arc<Mutex<WebSocketService>>,
    pub monitoring: Arc<MonitoringService>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    tracing_subscriber::fmt::init();
    
    // åŠ è½½é…ç½®
    let config = Arc::new(AppConfig::load()?);
    
    // åˆå§‹åŒ–æ•°æ®åº“æœåŠ¡
    let db = Arc::new(DatabaseService::new(&config.database_url).await?);
    
    // åˆå§‹åŒ–è®¤è¯æœåŠ¡
    let auth = Arc::new(AuthService::new(config.clone(), db.clone()));
    
    // åˆå§‹åŒ–WebSocketæœåŠ¡
    let websocket = Arc::new(Mutex::new(WebSocketService::new()));
    
    // åˆå§‹åŒ–ç›‘æ§æœåŠ¡
    let monitoring = Arc::new(MonitoringService::new(db.clone()));
    
    let app_state = AppState {
        config,
        db,
        auth,
        websocket,
        monitoring,
    };

    Builder::default()
        .manage(app_state)
        .invoke_handler(generate_handler![
            // è®¤è¯ç›¸å…³å‘½ä»¤
            auth::login,
            auth::logout,
            auth::refresh_token,
            auth::get_current_user,
            
            // å·¥å…·ç®¡ç†å‘½ä»¤
            services::tools::get_tools,
            services::tools::launch_tool,
            services::tools::track_usage,
            
            // ç›‘æ§ç›¸å…³å‘½ä»¤
            monitoring::get_system_metrics,
            monitoring::get_user_activities,
            monitoring::get_dashboard_data,
            
            // ç®¡ç†å‘˜å‘½ä»¤
            services::admin::get_users,
            services::admin::create_user,
            services::admin::update_user,
            services::admin::delete_user,
        ])
        .setup(|app| {
            // å¯åŠ¨åå°æœåŠ¡
            let handle = app.handle();
            let state = app.state::<AppState>();
            
            // å¯åŠ¨ç³»ç»Ÿç›‘æ§
            tokio::spawn(async move {
                let _ = state.monitoring.start_system_monitoring().await;
            });
            
            // å¯åŠ¨WebSocketæœåŠ¡
            tokio::spawn(async move {
                let _ = state.websocket.lock().await.start_server().await;
            });
            
            Ok(())
        })
        .on_window_event(|event| {
            if let WindowEvent::CloseRequested { api, .. } = event.event() {
                // ä¼˜é›…å…³é—­åº”ç”¨
                api.prevent_close();
                // æ‰§è¡Œæ¸…ç†æ“ä½œ
                event.window().hide().unwrap();
            }
        })
        .run(generate_context!())
        .expect("error while running tauri application");
    
    Ok(())
}
```

#### 1.2 é…ç½®ç®¡ç†æœåŠ¡ (src-tauri/src/config.rs)
```rust
use serde::{Deserialize, Serialize};
use std::env;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub database_url: String,
    pub jwt_secret: String,
    pub jwt_access_expiry: i64,  // ç§’
    pub jwt_refresh_expiry: i64, // ç§’
    pub websocket_port: u16,
    pub max_login_attempts: u32,
    pub session_timeout: i64,
    pub encryption_key: String,
    pub log_level: String,
}

impl AppConfig {
    pub fn load() -> Result<Self, config::ConfigError> {
        let mut settings = config::Config::builder();
        
        // ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®
        settings = settings
            .set_default("database_url", "mongodb://root:6scldk9f@dbconn.sealosbja.site:39056/chengshang_tools?directConnection=true")?
            .set_default("jwt_secret", "your-super-secret-jwt-key-change-this-in-production")?
            .set_default("jwt_access_expiry", 900)?  // 15åˆ†é’Ÿ
            .set_default("jwt_refresh_expiry", 604800)? // 7å¤©
            .set_default("websocket_port", 8080)?
            .set_default("max_login_attempts", 5)?
            .set_default("session_timeout", 3600)? // 1å°æ—¶
            .set_default("encryption_key", "your-32-byte-encryption-key-here")?
            .set_default("log_level", "info")?;

        // ä»ç¯å¢ƒå˜é‡è¦†ç›–é…ç½®
        if let Ok(db_url) = env::var("DATABASE_URL") {
            settings = settings.set_override("database_url", db_url)?;
        }
        
        if let Ok(jwt_secret) = env::var("JWT_SECRET") {
            settings = settings.set_override("jwt_secret", jwt_secret)?;
        }

        let config = settings.build()?.try_deserialize()?;
        Ok(config)
    }
}
```

#### 1.3 æ•°æ®åº“æœåŠ¡å®ç° (src-tauri/src/database.rs)
```rust
use mongodb::{
    Client, Database, Collection,
    bson::{doc, oid::ObjectId, Document},
    options::{ClientOptions, IndexOptions},
    IndexModel,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use anyhow::Result;

#[derive(Debug, Clone)]
pub struct DatabaseService {
    client: Client,
    database: Database,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct User {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub role: String,
    pub permissions: Vec<String>,
    pub profile: UserProfile,
    pub settings: UserSettings,
    pub status: String,
    pub last_login: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserProfile {
    pub display_name: String,
    pub avatar_url: Option<String>,
    pub department: String,
    pub position: String,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct UserSettings {
    pub theme: String,
    pub language: String,
    pub notifications: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserSession {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub user_id: ObjectId,
    pub refresh_token: String,
    pub access_token_jti: String,
    pub device_info: DeviceInfo,
    pub expires_at: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
    pub is_revoked: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct DeviceInfo {
    pub user_agent: String,
    pub ip_address: String,
    pub device_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SystemMetrics {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub timestamp: DateTime<Utc>,
    pub metrics: SystemResourceMetrics,
    pub application_metrics: ApplicationMetrics,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SystemResourceMetrics {
    pub cpu_usage: f64,
    pub memory_usage: f64,
    pub disk_usage: f64,
    pub network_io: NetworkMetrics,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct NetworkMetrics {
    pub bytes_sent: u64,
    pub bytes_received: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ApplicationMetrics {
    pub active_users: u32,
    pub concurrent_sessions: u32,
    pub tool_usage_count: u32,
    pub error_count: u32,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserActivity {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub user_id: ObjectId,
    pub activity_type: String,
    pub tool_id: Option<u32>,
    pub details: ActivityDetails,
    pub metadata: ActivityMetadata,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ActivityDetails {
    pub tool_name: Option<String>,
    pub duration: Option<u32>,
    pub success: bool,
    pub error_message: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ActivityMetadata {
    pub ip_address: String,
    pub user_agent: String,
    pub session_id: String,
}

impl DatabaseService {
    pub async fn new(connection_string: &str) -> Result<Self> {
        let client_options = ClientOptions::parse(connection_string).await?;
        let client = Client::with_options(client_options)?;
        let database = client.database("chengshang_tools");
        
        let service = DatabaseService { client, database };
        
        // åˆ›å»ºç´¢å¼•
        service.create_indexes().await?;
        
        Ok(service)
    }
    
    async fn create_indexes(&self) -> Result<()> {
        // ç”¨æˆ·é›†åˆç´¢å¼•
        let users_collection: Collection<User> = self.database.collection("users");
        let username_index = IndexModel::builder()
            .keys(doc! { "username": 1 })
            .options(IndexOptions::builder().unique(true).build())
            .build();
        let email_index = IndexModel::builder()
            .keys(doc! { "email": 1 })
            .options(IndexOptions::builder().unique(true).build())
            .build();
        users_collection.create_indexes(vec![username_index, email_index], None).await?;
        
        // ä¼šè¯é›†åˆç´¢å¼•
        let sessions_collection: Collection<UserSession> = self.database.collection("user_sessions");
        let session_index = IndexModel::builder()
            .keys(doc! { "user_id": 1, "expires_at": 1 })
            .build();
        sessions_collection.create_index(session_index, None).await?;
        
        // æ´»åŠ¨æ—¥å¿—ç´¢å¼•
        let activities_collection: Collection<UserActivity> = self.database.collection("user_activities");
        let activity_index = IndexModel::builder()
            .keys(doc! { "user_id": 1, "timestamp": -1 })
            .build();
        activities_collection.create_index(activity_index, None).await?;
        
        // ç³»ç»ŸæŒ‡æ ‡ç´¢å¼•
        let metrics_collection: Collection<SystemMetrics> = self.database.collection("system_metrics");
        let metrics_index = IndexModel::builder()
            .keys(doc! { "timestamp": -1 })
            .build();
        metrics_collection.create_index(metrics_index, None).await?;
        
        Ok(())
    }
    
    // ç”¨æˆ·ç®¡ç†æ–¹æ³•
    pub async fn create_user(&self, user: User) -> Result<ObjectId> {
        let collection: Collection<User> = self.database.collection("users");
        let result = collection.insert_one(user, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn find_user_by_username(&self, username: &str) -> Result<Option<User>> {
        let collection: Collection<User> = self.database.collection("users");
        let filter = doc! { "username": username };
        let user = collection.find_one(Some(filter), None).await?;
        Ok(user)
    }
    
    pub async fn find_user_by_email(&self, email: &str) -> Result<Option<User>> {
        let collection: Collection<User> = self.database.collection("users");
        let filter = doc! { "email": email };
        let user = collection.find_one(Some(filter), None).await?;
        Ok(user)
    }
    
    pub async fn update_user_last_login(&self, user_id: ObjectId) -> Result<()> {
        let collection: Collection<User> = self.database.collection("users");
        let filter = doc! { "_id": user_id };
        let update = doc! {
            "$set": {
                "last_login": Utc::now(),
                "updated_at": Utc::now()
            }
        };
        collection.update_one(filter, update, None).await?;
        Ok(())
    }
    
    // ä¼šè¯ç®¡ç†æ–¹æ³•
    pub async fn create_session(&self, session: UserSession) -> Result<ObjectId> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let result = collection.insert_one(session, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn find_session_by_token(&self, refresh_token: &str) -> Result<Option<UserSession>> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let filter = doc! {
            "refresh_token": refresh_token,
            "is_revoked": false,
            "expires_at": { "$gt": Utc::now() }
        };
        let session = collection.find_one(Some(filter), None).await?;
        Ok(session)
    }
    
    pub async fn revoke_session(&self, session_id: ObjectId) -> Result<()> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let filter = doc! { "_id": session_id };
        let update = doc! { "$set": { "is_revoked": true } };
        collection.update_one(filter, update, None).await?;
        Ok(())
    }
    
    pub async fn cleanup_expired_sessions(&self) -> Result<u64> {
        let collection: Collection<UserSession> = self.database.collection("user_sessions");
        let filter = doc! { "expires_at": { "$lt": Utc::now() } };
        let result = collection.delete_many(filter, None).await?;
        Ok(result.deleted_count)
    }
    
    // æ´»åŠ¨æ—¥å¿—æ–¹æ³•
    pub async fn log_user_activity(&self, activity: UserActivity) -> Result<ObjectId> {
        let collection: Collection<UserActivity> = self.database.collection("user_activities");
        let result = collection.insert_one(activity, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn get_user_activities(&self, user_id: ObjectId, limit: i64) -> Result<Vec<UserActivity>> {
        let collection: Collection<UserActivity> = self.database.collection("user_activities");
        let filter = doc! { "user_id": user_id };
        let options = mongodb::options::FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .limit(limit)
            .build();
        
        let mut cursor = collection.find(filter, options).await?;
        let mut activities = Vec::new();
        
        while cursor.advance().await? {
            activities.push(cursor.deserialize_current()?);
        }
        
        Ok(activities)
    }
    
    // ç³»ç»ŸæŒ‡æ ‡æ–¹æ³•
    pub async fn save_system_metrics(&self, metrics: SystemMetrics) -> Result<ObjectId> {
        let collection: Collection<SystemMetrics> = self.database.collection("system_metrics");
        let result = collection.insert_one(metrics, None).await?;
        Ok(result.inserted_id.as_object_id().unwrap())
    }
    
    pub async fn get_recent_metrics(&self, hours: i64) -> Result<Vec<SystemMetrics>> {
        let collection: Collection<SystemMetrics> = self.database.collection("system_metrics");
        let since = Utc::now() - chrono::Duration::hours(hours);
        let filter = doc! { "timestamp": { "$gte": since } };
        let options = mongodb::options::FindOptions::builder()
            .sort(doc! { "timestamp": -1 })
            .build();
        
        let mut cursor = collection.find(filter, options).await?;
        let mut metrics = Vec::new();
        
        while cursor.advance().await? {
            metrics.push(cursor.deserialize_current()?);
        }
        
        Ok(metrics)
    }
    
    // æ•°æ®åº“å¥åº·æ£€æŸ¥
    pub async fn health_check(&self) -> Result<Document> {
        let admin_db = self.client.database("admin");
        let result = admin_db.run_command(doc! { "ping": 1 }, None).await?;
        Ok(result)
    }
    
    // è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
    pub async fn get_database_stats(&self) -> Result<Document> {
        let result = self.database.run_command(doc! { "dbStats": 1 }, None).await?;
        Ok(result)
    }
}
```

#### 1.4 è®¤è¯æœåŠ¡æ ¸å¿ƒå®ç° (src-tauri/src/auth.rs)
```rust
use crate::database::{DatabaseService, User, UserSession, DeviceInfo};
use crate::config::AppConfig;
use crate::error::AuthError;

use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
use argon2::password_hash::{rand_core::OsRng, SaltString};
use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey, TokenData};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use chrono::{DateTime, Utc, Duration};
use uuid::Uuid;
use std::collections::HashMap;
use tokio::sync::RwLock;

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,      // ç”¨æˆ·ID
    pub username: String,
    pub role: String,
    pub permissions: Vec<String>,
    pub exp: i64,         // è¿‡æœŸæ—¶é—´
    pub iat: i64,         // ç­¾å‘æ—¶é—´
    pub jti: String,      // JWT ID
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
    pub device_info: DeviceInfo,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct LoginResponse {
    pub access_token: String,
    pub refresh_token: String,
    pub expires_in: i64,
    pub user: UserInfo,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct UserInfo {
    pub id: String,
    pub username: String,
    pub email: String,
    pub role: String,
    pub permissions: Vec<String>,
    pub profile: crate::database::UserProfile,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RefreshTokenRequest {
    pub refresh_token: String,
}

pub struct AuthService {
    config: Arc<AppConfig>,
    database: Arc<DatabaseService>,
    login_attempts: Arc<RwLock<HashMap<String, (u32, DateTime<Utc>)>>>,
}

impl AuthService {
    pub fn new(config: Arc<AppConfig>, database: Arc<DatabaseService>) -> Self {
        Self {
            config,
            database,
            login_attempts: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn login(&self, request: LoginRequest) -> Result<LoginResponse, AuthError> {
        // æ£€æŸ¥ç™»å½•é¢‘ç‡é™åˆ¶
        self.check_login_rate_limit(&request.username).await?;
        
        // éªŒè¯ç”¨æˆ·å‡­æ®
        let user = self.verify_credentials(&request.username, &request.password).await?;
        
        // ç”ŸæˆJWTä»¤ç‰Œ
        let (access_token, refresh_token) = self.generate_tokens(&user).await?;
        
        // åˆ›å»ºç”¨æˆ·ä¼šè¯
        let session = UserSession {
            id: None,
            user_id: user.id.unwrap(),
            refresh_token: refresh_token.clone(),
            access_token_jti: self.extract_jti_from_token(&access_token)?,
            device_info: request.device_info,
            expires_at: Utc::now() + Duration::seconds(self.config.jwt_refresh_expiry),
            created_at: Utc::now(),
            is_revoked: false,
        };
        
        self.database.create_session(session).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        // æ›´æ–°ç”¨æˆ·æœ€åç™»å½•æ—¶é—´
        self.database.update_user_last_login(user.id.unwrap()).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        // æ¸…é™¤ç™»å½•å°è¯•è®°å½•
        self.clear_login_attempts(&request.username).await;
        
        // è®°å½•ç™»å½•æ´»åŠ¨
        self.log_login_activity(&user, &request.device_info, true).await;
        
        Ok(LoginResponse {
            access_token,
            refresh_token,
            expires_in: self.config.jwt_access_expiry,
            user: UserInfo {
                id: user.id.unwrap().to_hex(),
                username: user.username,
                email: user.email,
                role: user.role,
                permissions: user.permissions,
                profile: user.profile,
            },
        })
    }
    
    pub async fn refresh_token(&self, request: RefreshTokenRequest) -> Result<LoginResponse, AuthError> {
        // éªŒè¯åˆ·æ–°ä»¤ç‰Œ
        let session = self.database.find_session_by_token(&request.refresh_token).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?
            .ok_or(AuthError::InvalidToken)?;
        
        // è·å–ç”¨æˆ·ä¿¡æ¯
        let user = self.database.find_user_by_username(&session.user_id.to_hex()).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?
            .ok_or(AuthError::UserNotFound)?;
        
        // ç”Ÿæˆæ–°çš„ä»¤ç‰Œ
        let (access_token, new_refresh_token) = self.generate_tokens(&user).await?;
        
        // æ’¤é”€æ—§çš„ä¼šè¯
        self.database.revoke_session(session.id.unwrap()).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        // åˆ›å»ºæ–°çš„ä¼šè¯
        let new_session = UserSession {
            id: None,
            user_id: user.id.unwrap(),
            refresh_token: new_refresh_token.clone(),
            access_token_jti: self.extract_jti_from_token(&access_token)?,
            device_info: session.device_info,
            expires_at: Utc::now() + Duration::seconds(self.config.jwt_refresh_expiry),
            created_at: Utc::now(),
            is_revoked: false,
        };
        
        self.database.create_session(new_session).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        
        Ok(LoginResponse {
            access_token,
            refresh_token: new_refresh_token,
            expires_in: self.config.jwt_access_expiry,
            user: UserInfo {
                id: user.id.unwrap().to_hex(),
                username: user.username,
                email: user.email,
                role: user.role,
                permissions: user.permissions,
                profile: user.profile,
            },
        })
    }
    
    pub async fn logout(&self, refresh_token: &str) -> Result<(), AuthError> {
        if let Some(session) = self.database.find_session_by_token(refresh_token).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))? {
            self.database.revoke_session(session.id.unwrap()).await
                .map_err(|e| AuthError::DatabaseError(e.to_string()))?;
        }
        Ok(())
    }
    
    pub async fn verify_token(&self, token: &str) -> Result<Claims, AuthError> {
        let token_data = decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.config.jwt_secret.as_ref()),
            &Validation::default(),
        ).map_err(|_| AuthError::InvalidToken)?;
        
        Ok(token_data.claims)
    }
    
    async fn verify_credentials(&self, username: &str, password: &str) -> Result<User, AuthError> {
        let user = self.database.find_user_by_username(username).await
            .map_err(|e| AuthError::DatabaseError(e.to_string()))?
            .ok_or(AuthError::InvalidCredentials)?;
        
        // éªŒè¯å¯†ç 
        let parsed_hash = PasswordHash::new(&user.password_hash)
            .map_err(|_| AuthError::InvalidCredentials)?;
        
        Argon2::default()
            .verify_password(password.as_bytes(), &parsed_hash)
            .map_err(|_| AuthError::InvalidCredentials)?;
        
        // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
        if user.status != "active" {
            return Err(AuthError::UserInactive);
        }
        
        Ok(user)
    }
    
    async fn generate_tokens(&self, user: &User) -> Result<(String, String), AuthError> {
        let now = Utc::now();
        let access_exp = now + Duration::seconds(self.config.jwt_access_expiry);
        let refresh_exp = now + Duration::seconds(self.config.jwt_refresh_expiry);
        
        // ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
        let access_claims = Claims {
            sub: user.id.unwrap().to_hex(),
            username: user.username.clone(),
            role: user.role.clone(),
            permissions: user.permissions.clone(),
            exp: access_exp.timestamp(),
            iat: now.timestamp(),
            jti: Uuid::new_v4().to_string(),
        };
        
        let access_token = encode(
            &Header::default(),
            &access_claims,
            &EncodingKey::from_secret(self.config.jwt_secret.as_ref()),
        ).map_err(|_| AuthError::TokenGenerationFailed)?;
        
        // ç”Ÿæˆåˆ·æ–°ä»¤ç‰Œ
        let refresh_claims = Claims {
            sub: user.id.unwrap().to_hex(),
            username: user.username.clone(),
            role: user.role.clone(),
            permissions: user.permissions.clone(),
            exp: refresh_exp.timestamp(),
            iat: now.timestamp(),
            jti: Uuid::new_v4().to_string(),
        };
        
        let refresh_token = encode(
            &Header::default(),
            &refresh_claims,
            &EncodingKey::from_secret(self.config.jwt_secret.as_ref()),
        ).map_err(|_| AuthError::TokenGenerationFailed)?;
        
        Ok((access_token, refresh_token))
    }
    
    async fn check_login_rate_limit(&self, username: &str) -> Result<(), AuthError> {
        let mut attempts = self.login_attempts.write().await;
        let now = Utc::now();
        
        if let Some((count, last_attempt)) = attempts.get(username) {
            // å¦‚æœè¶…è¿‡æœ€å¤§å°è¯•æ¬¡æ•°ä¸”åœ¨é”å®šæ—¶é—´å†…
            if *count >= self.config.max_login_attempts
                && now.signed_duration_since(*last_attempt).num_minutes() < 15 {
                return Err(AuthError::TooManyLoginAttempts);
            }
        }
        
        // è®°å½•ç™»å½•å°è¯•
        let current_count = attempts.get(username).map(|(c, _)| *c).unwrap_or(0);
        attempts.insert(username.to_string(), (current_count + 1, now));
        
        Ok(())
    }
    
    async fn clear_login_attempts(&self, username: &str) {
        let mut attempts = self.login_attempts.write().await;
        attempts.remove(username);
    }
    
    fn extract_jti_from_token(&self, token: &str) -> Result<String, AuthError> {
        let token_data = decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.config.jwt_secret.as_ref()),
            &Validation::default(),
        ).map_err(|_| AuthError::InvalidToken)?;
        
        Ok(token_data.claims.jti)
    }
    
    async fn log_login_activity(&self, user: &User, device_info: &DeviceInfo, success: bool) {
        use crate::database::{UserActivity, ActivityDetails, ActivityMetadata};
        
        let activity = UserActivity {
            id: None,
            user_id: user.id.unwrap(),
            activity_type: if success { "login".to_string() } else { "login_failed".to_string() },
            tool_id: None,
            details: ActivityDetails {
                tool_name: None,
                duration: None,
                success,
                error_message: if success { None } else { Some("Login failed".to_string()) },
            },
            metadata: ActivityMetadata {
                ip_address: device_info.ip_address.clone(),
                user_agent: device_info.user_agent.clone(),
                session_id: Uuid::new_v4().to_string(),
            },
            timestamp: Utc::now(),
        };
        
        let _ = self.database.log_user_activity(activity).await;
    }
    
    pub fn hash_password(password: &str) -> Result<String, AuthError> {
        let salt = SaltString::generate(&mut OsRng);
        let argon2 = Argon2::default();
        let password_hash = argon2
            .hash_password(password.as_bytes(), &salt)
            .map_err(|_| AuthError::PasswordHashingFailed)?
            .to_string();
        Ok(password_hash)
    }
}

// Tauriå‘½ä»¤å®ç°
#[tauri::command]
pub async fn login(
    state: tauri::State<'_, crate::AppState>,
    request: LoginRequest,
) -> Result<LoginResponse, String> {
    state.auth.login(request).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn logout(
    state: tauri::State<'_, crate::AppState>,
    refresh_token: String,
) -> Result<(), String> {
    state.auth.logout(&refresh_token).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn refresh_token(
    state: tauri::State<'_, crate::AppState>,
    request: RefreshTokenRequest,
) -> Result<LoginResponse, String> {
    state.auth.refresh_token(request).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_current_user(
    state: tauri::State<'_, crate::AppState>,
    access_token: String,
) -> Result<UserInfo, String> {
    let claims = state.auth.verify_token(&access_token).await
        .map_err(|e| e.to_string())?;
    
    let user = state.database.find_user_by_username(&claims.username).await
        .map_err(|e| e.to_string())?
        .ok_or("User not found")?;
    
    Ok(UserInfo {
        id: user.id.unwrap().to_hex(),
        username: user.username,
        email: user.email,
        role: user.role,
        permissions: user.permissions,
        profile: user.profile,
    })
}
```

## Phase 2: å‰ç«¯Reactç»„ä»¶å®ç°

### 2.1 ç™»å½•è¡¨å•ç»„ä»¶ (components/auth/login-form.tsx)
```typescript
'use client'

import { useState } from 'react'
import { motion } from 'framer-motion'
import { Eye, EyeOff, Lock, User, Loader2, AlertCircle } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { invoke } from '@tauri-apps/api/tauri'

export interface LoginFormData {
  username: string
  password: string
  device_info: {
    user_agent: string
    ip_address: string
    device_type: string
  }
}

export interface LoginResponse {
  access_token: string
  refresh_token: string
  expires_in: number
  user: {
    id: string
    username: string
    email: string
    role: string
    permissions: string[]
    profile: {
      display_name: string
      avatar_url?: string
      department: string
      position: string
    }
  }
}

export function LoginForm() {
  const [formData, setFormData] = useState({
    username: '',
    password: ''
  })
  const [showPassword, setShowPassword] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError(null)

    try {
      // è·å–è®¾å¤‡ä¿¡æ¯
      const deviceInfo = {
        user_agent: navigator.userAgent,
        ip_address: '127.0.0.1', // åœ¨å®é™…åº”ç”¨ä¸­ä»APIè·å–
        device_type: 'desktop'
      }

      const loginRequest: LoginFormData = {
        username: formData.username,
        password: formData.password,
        device_info: deviceInfo
      }

      // è°ƒç”¨Tauriåç«¯ç™»å½•å‘½ä»¤
      const response = await invoke<LoginResponse>('login', { request: loginRequest })
      
      // å­˜å‚¨ä»¤ç‰Œåˆ°æœ¬åœ°å­˜å‚¨
      localStorage.setItem('access_token', response.access_token)
      localStorage.setItem('refresh_token', response.refresh_token)
      localStorage.setItem('user_info', JSON.stringify(response.user))

      // è§¦å‘ç™»å½•æˆåŠŸäº‹ä»¶
      window.dispatchEvent(new CustomEvent('auth:login', {
        detail: { user: response.user }
      }))

    } catch (err: any) {
      setError(err.message || 'ç™»å½•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç ')
    } finally {
      setIsLoading(false)
    }
  }

  const inputVariants = {
    focus: { scale: 1.02, transition: { duration: 0.2 } },
    blur: { scale: 1, transition: { duration: 0.2 } }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-50/50 p-4">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="w-full max-w-md"
      >
        <Card className="backdrop-blur-sm bg-white/80 shadow-2xl border-0">
          <CardHeader className="space-y-1 text-center">
            <div className="flex justify-center mb-4">
              <div className="p-3 bg-gradient-to-r from-blue-600 to-purple-600 rounded-full">
                <Lock className="h-6 w-6 text-white" />
              </div>
            </div>
            <CardTitle className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
              å‘ˆå°šç­–åˆ’å·¥å…·ç®±
            </CardTitle>
            <CardDescription className="text-slate-600">
              ç™»å½•æ‚¨çš„è´¦æˆ·ä»¥è®¿é—®ä¸“ä¸šå·¥å…·
            </CardDescription>
          </CardHeader>
          
          <CardContent>
            <form onSubmit={handleSubmit} className="space-y-4">
              {error && (
                <motion.div
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  transition={{ duration: 0.3 }}
                >
                  <Alert variant="destructive" className="bg-red-50/80 border-red-200">
                    <AlertCircle className="h-4 w-4" />
                    <AlertDescription>{error}</AlertDescription>
                  </Alert>
                </motion.div>
              )}

              <div className="space-y-2">
                <Label htmlFor="username" className="text-sm font-medium text-slate-700">
                  ç”¨æˆ·å
                </Label>
                <motion.div
                  variants={inputVariants}
                  whileFocus="focus"
                  className="relative"
                >
                  <User className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                  <Input
                    id="username"
                    type="text"
                    placeholder="è¾“å…¥ç”¨æˆ·å"
                    value={formData.username}
                    onChange={(e) => setFormData(prev => ({ ...prev, username: e.target.value }))}
                    className="pl-10 h-11 bg-white/50 border-slate-200 focus:border-blue-400 focus:ring-blue-400/20"
                    required
                    disabled={isLoading}
                  />
                </motion.div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="password" className="text-sm font-medium text-slate-700">
                  å¯†ç 
                </Label>
                <motion.div
                  variants={inputVariants}
                  whileFocus="focus"
                  className="relative"
                >
                  <Lock className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-slate-400" />
                  <Input
                    id="password"
                    type={showPassword ? 'text' : 'password'}
                    placeholder="è¾“å…¥å¯†ç "
                    value={formData.password}
                    onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
                    className="pl-10 pr-10 h-11 bg-white/50 border-slate-200 focus:border-blue-400 focus:ring-blue-400/20"
                    required
                    disabled={isLoading}
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 text-slate-400 hover:text-slate-600 transition-colors"
                    disabled={isLoading}
                  >
                    {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                  </button>
                </motion.div>
              </div>

              <motion.div
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
                className="pt-2"
              >
                <Button
                  type="submit"
                  className="w-full h-11 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-medium shadow-lg hover:shadow-xl transition-all duration-200"
                  disabled={isLoading}
                >
                  {isLoading ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ç™»å½•ä¸­...
                    </>
                  ) : (
                    'ç™»å½•'
                  )}
                </Button>
              </motion.div>
            </form>

            <div className="mt-6 text-center text-sm text-slate-600">
              <p>å¿˜è®°å¯†ç ï¼Ÿè¯·è”ç³»ç³»ç»Ÿç®¡ç†å‘˜</p>
            </div>
          </CardContent>
        </Card>
      </motion.div>
    </div>
  )
}
```

### 2.2 ç®¡ç†åå°ä»ªè¡¨æ¿ç»„ä»¶ (components/admin/dashboard.tsx)
```typescript
'use client'

import { useState, useEffect } from 'react'
import { motion } from 'framer-motion'
import {
  Activity, Users, Server, Database, AlertTriangle,
  TrendingUp, Clock, Shield, BarChart3, Settings
} from 'lucide-react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Progress } from '@/components/ui/progress'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { invoke } from '@tauri-apps/api/tauri'

interface DashboardData {
  system_metrics: {
    cpu_usage: number
    memory_usage: number
    disk_usage: number
    network_io: {
      bytes_sent: number
      bytes_received: number
    }
  }
  application_metrics: {
    active_users: number
    concurrent_sessions: number
    tool_usage_count: number
    error_count: number
  }
  recent_activities: Array<{
    id: string
    user_id: string
    activity_type: string
    tool_name?: string
    timestamp: string
    success: boolean
  }>
  alerts: Array<{
    id: string
    type: 'warning' | 'error' | 'info'
    message: string
    timestamp: string
  }>
}

export function AdminDashboard() {
  const [dashboardData, setDashboardData] = useState<DashboardData | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null)

  // è·å–ä»ªè¡¨æ¿æ•°æ®
  const fetchDashboardData = async () => {
    try {
      const data = await invoke<DashboardData>('get_dashboard_data')
      setDashboardData(data)
      setLastUpdate(new Date())
    } catch (error) {
      console.error('Failed to fetch dashboard data:', error)
    } finally {
      setIsLoading(false)
    }
  }

  // ç»„ä»¶æŒ‚è½½æ—¶è·å–æ•°æ®ï¼Œå¹¶è®¾ç½®å®šæ—¶åˆ·æ–°
  useEffect(() => {
    fetchDashboardData()

    // è®¾ç½®WebSocketè¿æ¥ä»¥è·å–å®æ—¶æ›´æ–°
    const connectWebSocket = () => {
      const ws = new WebSocket('ws://localhost:8080/dashboard')
      
      ws.onmessage = (event) => {
        const update = JSON.parse(event.data)
        if (update.type === 'dashboard_update') {
          setDashboardData(update.data)
          setLastUpdate(new Date())
        }
      }

      ws.onclose = () => {
        // é‡è¿WebSocket
        setTimeout(connectWebSocket, 5000)
      }

      return ws
    }

    const ws = connectWebSocket()

    // æ¸…ç†å‡½æ•°
    return () => {
      ws.close()
    }
  }, [])

  if (isLoading || !dashboardData) {
    return (
      <div className="p-6 space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
          {[...Array(4)].map((_, i) => (
            <Card key={i} className="animate-pulse">
              <CardHeader className="space-y-2">
                <div className="h-4 bg-gray-200 rounded w-3/4"></div>
                <div className="h-8 bg-gray-200 rounded w-1/2"></div>
              </CardHeader>
            </Card>
          ))}
        </div>
      </div>
    )
  }

  const { system_metrics, application_metrics, recent_activities, alerts } = dashboardData

  return (
    <div className="p-6 space-y-6 bg-gradient-to-br from-slate-50 via-blue-50/30 to-indigo-50/50 min-h-screen">
      {/* é¡µé¢æ ‡é¢˜ */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
            ç³»ç»Ÿç®¡ç†ä»ªè¡¨æ¿
          </h1>
          <p className="text-slate-600 mt-1">
            å®æ—¶ç›‘æ§ç³»ç»ŸçŠ¶æ€å’Œåº”ç”¨æ€§èƒ½
            {lastUpdate && (
              <span className="ml-2 text-sm">
                æœ€åæ›´æ–°: {lastUpdate.toLocaleTimeString()}
              </span>
            )}
          </p>
        </div>
        <Button onClick={fetchDashboardData} variant="outline" size="sm">
          <Activity className="h-4 w-4 mr-2" />
          åˆ·æ–°æ•°æ®
        </Button>
      </div>

      {/* å‘Šè­¦ä¿¡æ¯ */}
      {alerts.length > 0 && (
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          className="space-y-2"
        >
          {alerts.slice(0, 3).map((alert) => (
            <Alert key={alert.id} variant={alert.type === 'error' ? 'destructive' : 'default'}>
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>
                {alert.message}
                <span className="ml-2 text-xs opacity-70">
                  {new Date(alert.timestamp).toLocaleString()}
                </span>
              </AlertDescription>
            </Alert>
          ))}
        </motion.div>
      )}

      {/* æ ¸å¿ƒæŒ‡æ ‡å¡ç‰‡ */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.1 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">æ´»è·ƒç”¨æˆ·</CardTitle>
              <Users className="h-4 w-4 text-blue-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {application_metrics.active_users}
              </div>
              <p className="text-xs text-slate-600 mt-1">
                å½“å‰åœ¨çº¿ç”¨æˆ·æ•°é‡
              </p>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.2 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">å·¥å…·ä½¿ç”¨</CardTitle>
              <BarChart3 className="h-4 w-4 text-green-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {application_metrics.tool_usage_count}
              </div>
              <p className="text-xs text-slate-600 mt-1">
                ä»Šæ—¥å·¥å…·è®¿é—®æ¬¡æ•°
              </p>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.3 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">ç³»ç»Ÿè´Ÿè½½</CardTitle>
              <Server className="h-4 w-4 text-orange-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {system_metrics.cpu_usage.toFixed(1)}%
              </div>
              <p className="text-xs text-slate-600 mt-1">
                CPUä½¿ç”¨ç‡
              </p>
            </CardContent>
          </Card>
        </motion.div>

        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ delay: 0.4 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg hover:shadow-xl transition-shadow">
            <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
              <CardTitle className="text-sm font-medium text-slate-600">é”™è¯¯æ•°é‡</CardTitle>
              <AlertTriangle className="h-4 w-4 text-red-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-slate-900">
                {application_metrics.error_count}
              </div>
              <p className="text-xs text-slate-600 mt-1">
                ä»Šæ—¥é”™è¯¯æŠ¥å‘Š
              </p>
            </CardContent>
          </Card>
        </motion.div>
      </div>

      {/* è¯¦ç»†ç›‘æ§æ•°æ® */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* ç³»ç»Ÿèµ„æºç›‘æ§ */}
        <motion.div
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.5 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg">
            <CardHeader>
              <CardTitle className="flex items-center">
                <Server className="h-5 w-5 mr-2 text-blue-600" />
                ç³»ç»Ÿèµ„æºç›‘æ§
              </CardTitle>
              <CardDescription>å®æ—¶ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-slate-600">CPUä½¿ç”¨ç‡</span>
                  <span className="text-sm font-medium">{system_metrics.cpu_usage.toFixed(1)}%</span>
                </div>
                <Progress value={system_metrics.cpu_usage} className="h-2" />
              </div>

              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-slate-600">å†…å­˜ä½¿ç”¨ç‡</span>
                  <span className="text-sm font-medium">{system_metrics.memory_usage.toFixed(1)}%</span>
                </div>
                <Progress value={system_metrics.memory_usage} className="h-2" />
              </div>

              <div className="space-y-3">
                <div className="flex items-center justify-between">
                  <span className="text-sm text-slate-600">ç£ç›˜ä½¿ç”¨ç‡</span>
                  <span className="text-sm font-medium">{system_metrics.disk_usage.toFixed(1)}%</span>
                </div>
                <Progress value={system_metrics.disk_usage} className="h-2" />
              </div>

              <div className="pt-2 border-t">
                <div className="flex justify-between text-sm">
                  <span className="text-slate-600">ç½‘ç»œå‘é€</span>
                  <span className="font-medium">
                    {(system_metrics.network_io.bytes_sent / 1024 / 1024).toFixed(2)} MB
                  </span>
                </div>
                <div className="flex justify-between text-sm mt-1">
                  <span className="text-slate-600">ç½‘ç»œæ¥æ”¶</span>
                  <span className="font-medium">
                    {(system_metrics.network_io.bytes_received / 1024 / 1024).toFixed(2)} MB
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>
        </motion.div>

        {/* ç”¨æˆ·æ´»åŠ¨æ—¥å¿— */}
        <motion.div
          initial={{ opacity: 0, x: 20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: 0.6 }}
        >
          <Card className="bg-white/80 backdrop-blur-sm border-0 shadow-lg">
            <CardHeader>
              <CardTitle className="flex items-center">
                <Activity className="h-5 w-5 mr-2 text-green-600" />
                æœ€è¿‘æ´»åŠ¨
              </CardTitle>
              <CardDescription>ç”¨æˆ·æ“ä½œæ—¥å¿—è®°å½•</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-3 max-h-80 overflow-y-auto">
                {recent_activities.map((activity) => (
                  <div key={activity.id} className="flex items-center justify-between p-3 bg-slate-50/50 rounded-lg">
                    <div className="flex items-center space-x-3">
                      <div className={`w-2 h-2 rounded-full ${
                        activity.success ? 'bg-green-500' : 'bg-red-500'
                      }`} />
                      <div>
                        <p className="text-sm font-medium text-slate-900">
                          {activity.activity_type === 'login' ? 'ç”¨æˆ·ç™»å½•' :
                           activity.activity_type === 'tool_access' ? `ä½¿ç”¨å·¥å…·: ${activity.tool_name}` :
                           activity.activity_type}
                        </p>
                        <p className="text-xs text-slate-500">
                          {new Date(activity.timestamp).toLocaleString()}
                        </p>
                      </div>
                    </div>
                    <Badge variant={activity.success ? "default" : "destructive"} className="text-xs">
                      {activity.success ? 'æˆåŠŸ' : 'å¤±è´¥'}
                    </Badge>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </motion.div>
      </div>
    </div>
  )
}
```

### 2.3 WebSocketå®æ—¶é€šä¿¡æœåŠ¡ (src-tauri/src/websocket.rs)
```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, mpsc};
use tokio_tungstenite::{accept_async, WebSocketStream};
use tokio::net::{TcpListener, TcpStream};
use tungstenite::protocol::Message;
use futures_util::{SinkExt, StreamExt};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use tracing::{info, error, warn};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebSocketMessage {
    pub message_type: String,
    pub data: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug)]
pub struct WebSocketClient {
    pub id: String,
    pub user_id: Option<String>,
    pub sender: mpsc::UnboundedSender<WebSocketMessage>,
}

pub struct WebSocketService {
    clients: Arc<RwLock<HashMap<String, WebSocketClient>>>,
    message_sender: Option<mpsc::UnboundedSender<BroadcastMessage>>,
}

#[derive(Debug, Clone)]
pub struct BroadcastMessage {
    pub target: BroadcastTarget,
    pub message: WebSocketMessage,
}

#[derive(Debug, Clone)]
pub enum BroadcastTarget {
    All,
    User(String),
    Clients(Vec<String>),
}

impl WebSocketService {
    pub fn new() -> Self {
        Self {
            clients: Arc::new(RwLock::new(HashMap::new())),
            message_sender: None,
        }
    }

    pub async fn start_server(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let addr = "127.0.0.1:8080";
        let listener = TcpListener::bind(addr).await?;
        info!("WebSocket server listening on: {}", addr);

        // åˆ›å»ºå¹¿æ’­æ¶ˆæ¯é€šé“
        let (broadcast_tx, mut broadcast_rx) = mpsc::unbounded_channel::<BroadcastMessage>();
        self.message_sender = Some(broadcast_tx);

        let clients = self.clients.clone();

        // å¯åŠ¨å¹¿æ’­æ¶ˆæ¯å¤„ç†ä»»åŠ¡
        let broadcast_clients = clients.clone();
        tokio::spawn(async move {
            while let Some(broadcast_msg) = broadcast_rx.recv().await {
                let clients_lock = broadcast_clients.read().await;
                
                match &broadcast_msg.target {
                    BroadcastTarget::All => {
                        for client in clients_lock.values() {
                            let _ = client.sender.send(broadcast_msg.message.clone());
                        }
                    }
                    BroadcastTarget::User(user_id) => {
                        for client in clients_lock.values() {
                            if client.user_id.as_ref() == Some(user_id) {
                                let _ = client.sender.send(broadcast_msg.message.clone());
                            }
                        }
                    }
                    BroadcastTarget::Clients(client_ids) => {
                        for client_id in client_ids {
                            if let Some(client) = clients_lock.get(client_id) {
                                let _ = client.sender.send(broadcast_msg.message.clone());
                            }
                        }
                    }
                }
            }
        });

        // æ¥å—WebSocketè¿æ¥
        while let Ok((stream, addr)) = listener.accept().await {
            let clients = clients.clone();
            tokio::spawn(async move {
                if let Err(e) = Self::handle_connection(stream, addr, clients).await {
                    error!("Error handling WebSocket connection: {}", e);
                }
            });
        }

        Ok(())
    }

    async fn handle_connection(
        stream: TcpStream,
        addr: std::net::SocketAddr,
        clients: Arc<RwLock<HashMap<String, WebSocketClient>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        info!("New WebSocket connection from: {}", addr);

        let ws_stream = accept_async(stream).await?;
        let client_id = Uuid::new_v4().to_string();
        
        let (mut ws_sender, mut ws_receiver) = ws_stream.split();
        let (client_tx, mut client_rx) = mpsc::unbounded_channel::<WebSocketMessage>();

        // åˆ›å»ºå®¢æˆ·ç«¯è®°å½•
        let client = WebSocketClient {
            id: client_id.clone(),
            user_id: None,
            sender: client_tx,
        };

        // æ³¨å†Œå®¢æˆ·ç«¯
        {
            let mut clients_lock = clients.write().await;
            clients_lock.insert(client_id.clone(), client);
        }

        // å‘é€æ¬¢è¿æ¶ˆæ¯
        let welcome_msg = WebSocketMessage {
            message_type: "welcome".to_string(),
            data: serde_json::json!({
                "client_id": client_id,
                "message": "Connected to WebSocket server"
            }),
            timestamp: chrono::Utc::now(),
        };

        if let Ok(msg_str) = serde_json::to_string(&welcome_msg) {
            let _ = ws_sender.send(Message::Text(msg_str)).await;
        }

        // å¯åŠ¨å‘é€ä»»åŠ¡
        let mut send_task = tokio::spawn(async move {
            while let Some(message) = client_rx.recv().await {
                if let Ok(msg_str) = serde_json::to_string(&message) {
                    if ws_sender.send(Message::Text(msg_str)).await.is_err() {
                        break;
                    }
                } else {
                    warn!("Failed to serialize WebSocket message");
                }
            }
        });

        // å¯åŠ¨æ¥æ”¶ä»»åŠ¡
        let client_id_clone = client_id.clone();
        let clients_clone = clients.clone();
        let mut recv_task = tokio::spawn(async move {
            while let Some(msg) = ws_receiver.next().await {
                match msg {
                    Ok(Message::Text(text)) => {
                        if let Err(e) = Self::handle_client_message(&client_id_clone, &text, &clients_clone).await {
                            error!("Error handling client message: {}", e);
                        }
                    }
                    Ok(Message::Close(_)) => {
                        info!("Client {} requested close", client_id_clone);
                        break;
                    }
                    Err(e) => {
                        error!("WebSocket error: {}", e);
                        break;
                    }
                    _ => {}
                }
            }
        });

        // ç­‰å¾…ä»»åŠ¡å®Œæˆ
        tokio::select! {
            _ = (&mut send_task) => {
                recv_task.abort();
            }
            _ = (&mut recv_task) => {
                send_task.abort();
            }
        }

        // æ¸…ç†å®¢æˆ·ç«¯
        {
            let mut clients_lock = clients.write().await;
            clients_lock.remove(&client_id);
        }

        info!("Client {} disconnected", client_id);
        Ok(())
    }

    async fn handle_client_message(
        client_id: &str,
        message: &str,
        clients: &Arc<RwLock<HashMap<String, WebSocketClient>>>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let msg: serde_json::Value = serde_json::from_str(message)?;
        
        if let Some(msg_type) = msg.get("type").and_then(|v| v.as_str()) {
            match msg_type {
                "auth" => {
                    if let Some(user_id) = msg.get("user_id").and_then(|v| v.as_str()) {
                        // æ›´æ–°å®¢æˆ·ç«¯çš„ç”¨æˆ·ID
                        let mut clients_lock = clients.write().await;
                        if let Some(client) = clients_lock.get_mut(client_id) {
                            client.user_id = Some(user_id.to_string());
                            info!("Client {} authenticated as user {}", client_id, user_id);
                        }
                    }
                }
                "ping" => {
                    // å‘é€pongå“åº”
                    if let Some(client) = clients.read().await.get(client_id) {
                        let pong_msg = WebSocketMessage {
                            message_type: "pong".to_string(),
                            data: serde_json::json!({"timestamp": chrono::Utc::now()}),
                            timestamp: chrono::Utc::now(),
                        };
                        let _ = client.sender.send(pong_msg);
                    }
                }
                _ => {
                    warn!("Unknown message type: {}", msg_type);
                }
            }
        }

        Ok(())
    }

    pub async fn broadcast_to_all(&self, message: WebSocketMessage) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(sender) = &self.message_sender {
            let broadcast_msg = BroadcastMessage {
                target: BroadcastTarget::All,
                message,
            };
            sender.send(broadcast_msg)?;
        }
        Ok(())
    }

    pub async fn send_to_user(&self, user_id: &str, message: WebSocketMessage) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(sender) = &self.message_sender {
            let broadcast_msg = BroadcastMessage {
                target: BroadcastTarget::User(user_id.to_string()),
                message,
            };
            sender.send(broadcast_msg)?;
        }
        Ok(())
    }

    pub async fn get_connected_users(&self) -> Vec<String> {
        let clients = self.clients.read().await;
        clients
            .values()
            .filter_map(|client| client.user_id.clone())
            .collect()
    }

    pub async fn get_client_count(&self) -> usize {
        self.clients.read().await.len()
    }
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºç³»ç»Ÿé€šçŸ¥æ¶ˆæ¯
pub fn create_system_notification(title: &str, message: &str, level: &str) -> WebSocketMessage {
    WebSocketMessage {
        message_type: "system_notification".to_string(),
        data: serde_json::json!({
            "title": title,
            "message": message,
            "level": level,
            "id": Uuid::new_v4().to_string()
        }),
        timestamp: chrono::Utc::now(),
    }
}

// è¾…åŠ©å‡½æ•°ï¼šåˆ›å»ºä»ªè¡¨æ¿æ›´æ–°æ¶ˆæ¯
pub fn create_dashboard_update(data: serde_json::Value) -> WebSocketMessage {
    WebSocketMessage {
        message_type: "dashboard_update".to_string(),
        data,
        timestamp: chrono::Utc::now(),
    }
}
```

### 2.4 ç³»ç»Ÿç›‘æ§æœåŠ¡ (src-tauri/src/monitoring.rs)
```rust
use crate::database::{DatabaseService, SystemMetrics, SystemResourceMetrics, NetworkMetrics, ApplicationMetrics};
use crate::websocket::{WebSocketService, create_dashboard_update, create_system_notification};

use std::sync::Arc;
use std::time::Duration;
use sysinfo::{System, SystemExt, CpuExt, DiskExt, NetworkExt, ProcessExt};
use tokio::time::sleep;
use chrono::Utc;
use serde_json::json;
use tracing::{info, error, warn};

pub struct MonitoringService {
    database: Arc<DatabaseService>,
    system: Arc<tokio::sync::Mutex<System>>,
}

#[derive(Debug, Clone)]
pub struct MonitoringConfig {
    pub collection_interval: Duration,
    pub alert_thresholds: AlertThresholds,
}

#[derive(Debug, Clone)]
pub struct AlertThresholds {
    pub cpu_warning: f64,      // CPUä½¿ç”¨ç‡è­¦å‘Šé˜ˆå€¼
    pub cpu_critical: f64,     // CPUä½¿ç”¨ç‡ä¸¥é‡é˜ˆå€¼
    pub memory_warning: f64,   // å†…å­˜ä½¿ç”¨ç‡è­¦å‘Šé˜ˆå€¼
    pub memory_critical: f64,  // å†…å­˜ä½¿ç”¨ç‡ä¸¥é‡é˜ˆå€¼
    pub disk_warning: f64,     // ç£ç›˜ä½¿ç”¨ç‡è­¦å‘Šé˜ˆå€¼
    pub disk_critical: f64,    // ç£ç›˜ä½¿ç”¨ç‡ä¸¥é‡é˜ˆå€¼
}

impl Default for AlertThresholds {
    fn default() -> Self {
        Self {
            cpu_warning: 70.0,
            cpu_critical: 90.0,
            memory_warning: 80.0,
            memory_critical: 95.0,
            disk_warning: 85.0,
            disk_critical: 95.0,
        }
    }
}

impl MonitoringService {
    pub fn new(database: Arc<DatabaseService>) -> Self {
        let mut system = System::new_all();
        system.refresh_all();
        
        Self {
            database,
            system: Arc::new(tokio::sync::Mutex::new(system)),
        }
    }

    pub async fn start_system_monitoring(&self) -> Result<(), Box<dyn std::error::Error>> {
        let config = MonitoringConfig {
            collection_interval: Duration::from_secs(30), // æ¯30ç§’æ”¶é›†ä¸€æ¬¡
            alert_thresholds: AlertThresholds::default(),
        };

        info!("Starting system monitoring with interval: {:?}", config.collection_interval);

        loop {
            if let Err(e) = self.collect_and_store_metrics(&config).await {
                error!("Error collecting system metrics: {}", e);
            }

            sleep(config.collection_interval).await;
        }
    }

    async fn collect_and_store_metrics(&self, config: &MonitoringConfig) -> Result<(), Box<dyn std::error::Error>> {
        // åˆ·æ–°ç³»ç»Ÿä¿¡æ¯
        {
            let mut system = self.system.lock().await;
            system.refresh_all();
        }

        // æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
        let system_metrics = self.collect_system_metrics().await?;
        
        // æ”¶é›†åº”ç”¨æŒ‡æ ‡
        let app_metrics = self.collect_application_metrics().await?;

        // åˆ›å»ºæŒ‡æ ‡è®°å½•
        let metrics = SystemMetrics {
            id: None,
            timestamp: Utc::now(),
            metrics: system_metrics.clone(),
            application_metrics: app_metrics.clone(),
        };

        // å­˜å‚¨åˆ°æ•°æ®åº“
        if let Err(e) = self.database.save_system_metrics(metrics).await {
            error!("Failed to save system metrics: {}", e);
        }

        // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
        self.check_alerts(&system_metrics, &config.alert_thresholds).await;

        // æ„å»ºä»ªè¡¨æ¿æ•°æ®
        let dashboard_data = json!({
            "system_metrics": {
                "cpu_usage": system_metrics.cpu_usage,
                "memory_usage": system_metrics.memory_usage,
                "disk_usage": system_metrics.disk_usage,
                "network_io": system_metrics.network_io
            },
            "application_metrics": {
                "active_users": app_metrics.active_users,
                "concurrent_sessions": app_metrics.concurrent_sessions,
                "tool_usage_count": app_metrics.tool_usage_count,
                "error_count": app_metrics.error_count
            },
            "timestamp": Utc::now()
        });

        info!("Collected metrics - CPU: {:.1}%, Memory: {:.1}%, Disk: {:.1}%",
            system_metrics.cpu_usage,
            system_metrics.memory_usage,
            system_metrics.disk_usage
        );

        Ok(())
    }

    async fn collect_system_metrics(&self) -> Result<SystemResourceMetrics, Box<dyn std::error::Error>> {
        let system = self.system.lock().await;

        // CPUä½¿ç”¨ç‡
        let cpu_usage = system.global_cpu_info().cpu_usage() as f64;

        // å†…å­˜ä½¿ç”¨ç‡
        let total_memory = system.total_memory();
        let used_memory = system.used_memory();
        let memory_usage = if total_memory > 0 {
            (used_memory as f64 / total_memory as f64) * 100.0
        } else {
            0.0
        };

        // ç£ç›˜ä½¿ç”¨ç‡ï¼ˆå–ä¸»è¦ç£ç›˜ï¼‰
        let mut disk_usage = 0.0;
        if let Some(disk) = system.disks().first() {
            let total_space = disk.total_space();
            let available_space = disk.available_space();
            let used_space = total_space - available_space;
            
            if total_space > 0 {
                disk_usage = (used_space as f64 / total_space as f64) * 100.0;
            }
        }

        // ç½‘ç»œIOï¼ˆç´¯è®¡å€¼ï¼‰
        let mut bytes_sent = 0u64;
        let mut bytes_received = 0u64;
        
        for (_, network) in system.networks() {
            bytes_sent += network.total_transmitted();
            bytes_received += network.total_received();
        }

        Ok(SystemResourceMetrics {
            cpu_usage,
            memory_usage,
            disk_usage,
            network_io: NetworkMetrics {
                bytes_sent,
                bytes_received,
            },
        })
    }

    async fn collect_application_metrics(&self) -> Result<ApplicationMetrics, Box<dyn std::error::Error>> {
        // è¿™é‡Œéœ€è¦å®ç°åº”ç”¨çº§åˆ«çš„æŒ‡æ ‡æ”¶é›†
        // ç”±äºæ˜¯ç¤ºä¾‹ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
        
        // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™äº›æ•°æ®åº”è¯¥ä»ï¼š
        // 1. WebSocketæœåŠ¡è·å–æ´»è·ƒç”¨æˆ·å’Œå¹¶å‘ä¼šè¯æ•°
        // 2. æ•°æ®åº“æŸ¥è¯¢è·å–å·¥å…·ä½¿ç”¨ç»Ÿè®¡
        // 3. é”™è¯¯æ—¥å¿—ç³»ç»Ÿè·å–é”™è¯¯æ•°é‡

        Ok(ApplicationMetrics {
            active_users: 12,      // ä»WebSocketæœåŠ¡è·å–
            concurrent_sessions: 8, // ä»ä¼šè¯ç®¡ç†è·å–
            tool_usage_count: 156,  // ä»æ•°æ®åº“ç»Ÿè®¡ä»Šæ—¥å·¥å…·ä½¿ç”¨æ¬¡æ•°
            error_count: 3,         // ä»é”™è¯¯æ—¥å¿—ç»Ÿè®¡ä»Šæ—¥é”™è¯¯æ•°é‡
        })
    }

    async fn check_alerts(&self, metrics: &SystemResourceMetrics, thresholds: &AlertThresholds) {
        // æ£€æŸ¥CPUå‘Šè­¦
        if metrics.cpu_usage >= thresholds.cpu_critical {
            let msg = create_system_notification(
                "ä¸¥é‡å‘Šè­¦",
                &format!("CPUä½¿ç”¨ç‡è¿‡é«˜: {:.1}%", metrics.cpu_usage),
                "error"
            );
            // è¿™é‡Œéœ€è¦é€šè¿‡WebSocketå‘é€å‘Šè­¦
            warn!("Critical CPU usage: {:.1}%", metrics.cpu_usage);
        } else if metrics.cpu_usage >= thresholds.cpu_warning {
            let msg = create_system_notification(
                "è­¦å‘Š",
                &format!("CPUä½¿ç”¨ç‡è¾ƒé«˜: {:.1}%", metrics.cpu_usage),
                "warning"
            );
            warn!("High CPU usage: {:.1}%", metrics.cpu_usage);
        }

        // æ£€æŸ¥å†…å­˜å‘Šè­¦
        if metrics.memory_usage >= thresholds.memory_critical {
            let msg = create_system_notification(
                "ä¸¥é‡å‘Šè­¦",
                &format!("å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: {:.1}%", metrics.memory_usage),
                "error"
            );
            warn!("Critical memory usage: {:.1}%", metrics.memory_usage);
        } else if metrics.memory_usage >= thresholds.memory_warning {
            let msg = create_system_notification(
                "è­¦å‘Š",
                &format!("å†…å­˜ä½¿ç”¨ç‡è¾ƒé«˜: {:.1}%", metrics.memory_usage),
                "warning"
            );
            warn!("High memory usage: {:.1}%", metrics.memory_usage);
        }

        // æ£€æŸ¥ç£ç›˜å‘Šè­¦
        if metrics.disk_usage >= thresholds.disk_critical {
            let msg = create_system_notification(
                "ä¸¥é‡å‘Šè­¦",
                &format!("ç£ç›˜ä½¿ç”¨ç‡è¿‡é«˜: {:.1}%", metrics.disk_usage),
                "error"
            );
            warn!("Critical disk usage: {:.1}%", metrics.disk_usage);
        } else if metrics.disk_usage >= thresholds.disk_warning {
            let msg = create_system_notification(
                "è­¦å‘Š",
                &format!("ç£ç›˜ä½¿ç”¨ç‡è¾ƒé«˜: {:.1}%", metrics.disk_usage),
                "warning"
            );
            warn!("High disk usage: {:.1}%", metrics.disk_usage);
        }
    }

    pub async fn get_system_health(&self) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let metrics = self.collect_system_metrics().await?;
        let app_metrics = self.collect_application_metrics().await?;

        Ok(json!({
            "status": "healthy",
            "timestamp": Utc::now(),
            "system": {
                "cpu_usage": metrics.cpu_usage,
                "memory_usage": metrics.memory_usage,
                "disk_usage": metrics.disk_usage,
                "network_io": metrics.network_io
            },
            "application": {
                "active_users": app_metrics.active_users,
                "concurrent_sessions": app_metrics.concurrent_sessions,
                "tool_usage_count": app_metrics.tool_usage_count,
                "error_count": app_metrics.error_count
            }
        }))
    }
}

// Tauriå‘½ä»¤å®ç°
#[tauri::command]
pub async fn get_system_metrics(
    state: tauri::State<'_, crate::AppState>,
) -> Result<serde_json::Value, String> {
    state.monitoring.get_system_health().await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_user_activities(
    state: tauri::State<'_, crate::AppState>,
    user_id: String,
    limit: i64,
) -> Result<Vec<crate::database::UserActivity>, String> {
    use mongodb::bson::oid::ObjectId;
    
    let user_object_id = ObjectId::parse_str(&user_id)
        .map_err(|e| format!("Invalid user ID: {}", e))?;
    
    state.database.get_user_activities(user_object_id, limit).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_dashboard_data(
    state: tauri::State<'_, crate::AppState>,
) -> Result<serde_json::Value, String> {
    // è·å–ç³»ç»ŸæŒ‡æ ‡
    let system_health = state.monitoring.get_system_health().await
        .map_err(|e| e.to_string())?;
    
    // è·å–æœ€è¿‘çš„æ´»åŠ¨æ—¥å¿—ï¼ˆç¤ºä¾‹æ•°æ®ï¼‰
    let recent_activities = json!([
        {
            "id": "1",
            "user_id": "user1",
            "activity_type": "login",
            "timestamp": Utc::now(),
            "success": true
        },
        {
            "id": "2",
            "user_id": "user2",
            "activity_type": "tool_access",
            "tool_name": "å•†å®¶å›å¤è§£ç­”æ‰‹å†Œ",
            "timestamp": Utc::now(),
            "success": true
        }
    ]);

    // è·å–å‘Šè­¦ä¿¡æ¯ï¼ˆç¤ºä¾‹æ•°æ®ï¼‰
    let alerts = json!([]);

    Ok(json!({
        "system_metrics": system_health["system"],
        "application_metrics": system_health["application"],
        "recent_activities": recent_activities,
        "alerts": alerts,
        "timestamp": Utc::now()
    }))
}
```


## Phase 3: éƒ¨ç½²é…ç½®ä¸å®‰å…¨ç­–ç•¥å®ç°

### 3.0 Windowså¼€å‘ç¯å¢ƒé…ç½®è§£å†³æ–¹æ¡ˆ

#### Microsoft C++æ„å»ºå·¥å…·é—®é¢˜è§£å†³
å½“å‰é¡¹ç›®åœ¨Windowsç¯å¢ƒä¸‹éœ€è¦Microsoft C++æ„å»ºå·¥å…·æ”¯æŒï¼Œå·²æä¾›å®Œæ•´è§£å†³æ–¹æ¡ˆï¼š

**æ–¹æ¡ˆä¸€ï¼šå®‰è£… Visual Studio Build Tools 2022ï¼ˆå¼ºçƒˆæ¨èï¼‰**
```bash
# ä¸‹è½½åœ°å€ï¼šhttps://visualstudio.microsoft.com/downloads/
# æˆ–ç›´æ¥ä¸‹è½½ï¼šhttps://aka.ms/vs/17/release/vs_buildtools.exe

# åœ¨ Visual Studio Installer ä¸­é€‰æ‹©ï¼š
# âœ… C++ ç”Ÿæˆå·¥å…·
# âœ… Windows 10/11 SDKï¼ˆæœ€æ–°ç‰ˆæœ¬ï¼‰
# âœ… MSVC v143 - VS 2022 C++ x64/x86 ç”Ÿæˆå·¥å…·
# âœ… CMake å·¥å…·ï¼ˆå¯é€‰ä½†æ¨èï¼‰
```

**æ–¹æ¡ˆäºŒï¼šä½¿ç”¨ GNU å·¥å…·é“¾ï¼ˆä¸´æ—¶æ–¹æ¡ˆï¼‰**
```bash
rustup toolchain install stable-x86_64-pc-windows-gnu
rustup default stable-x86_64-pc-windows-gnu
```

**éªŒè¯å®‰è£…**
```bash
# æ£€æŸ¥ Microsoft C++ é“¾æ¥å™¨
where link.exe

# æ£€æŸ¥ Rust å·¥å…·é“¾
rustc --version
rustup show
```

### 3.1 NSISå®‰è£…åŒ…æ„å»ºå®Œæ•´æ–¹æ¡ˆ

é¡¹ç›®å·²é‡‡ç”¨NSISä½œä¸ºWindowså¹³å°çš„ä¸“ä¸šå®‰è£…åŒ…è§£å†³æ–¹æ¡ˆï¼Œç›¸æ¯”ç›´æ¥EXEåˆ†å‘å…·æœ‰æ˜¾è‘—ä¼˜åŠ¿ï¼š

#### NSIS vs å…¶ä»–æ–¹æ¡ˆå¯¹æ¯”

| ç‰¹æ€§ | ç›´æ¥EXE | MSI | NSIS |
|------|---------|-----|------|
| **ç”¨æˆ·ä½“éªŒ** | âš ï¸ ç®€å• | âœ… ä¸“ä¸š | âœ… **æœ€ä½³** |
| **ä¾èµ–æ£€æµ‹** | âŒ æ—  | âš ï¸ åŸºç¡€ | âœ… **æ™ºèƒ½** |
| **å®‰è£…å®šåˆ¶** | âŒ æ—  | âš ï¸ æœ‰é™ | âœ… **å®Œå…¨å¯å®šåˆ¶** |
| **é”™è¯¯å¤„ç†** | âŒ ç³»ç»Ÿçº§ | âš ï¸ åŸºç¡€ | âœ… **ç”¨æˆ·å‹å¥½** |
| **ä¼ä¸šéƒ¨ç½²** | âŒ å›°éš¾ | âœ… æ”¯æŒ | âœ… **å®Œå…¨æ”¯æŒ** |

#### NSISæ ¸å¿ƒä¼˜åŠ¿
1. **æ™ºèƒ½ä¾èµ–ç®¡ç†** - è‡ªåŠ¨æ£€æµ‹WebView2è¿è¡Œæ—¶ï¼Œæä¾›æ¸…æ™°çš„å®‰è£…æŒ‡å¯¼
2. **ä¸“ä¸šå®‰è£…ä½“éªŒ** - ç°ä»£åŒ–å®‰è£…ç•Œé¢ï¼Œè¿›åº¦æ˜¾ç¤ºå’ŒçŠ¶æ€åé¦ˆ
3. **ä¼ä¸šçº§éƒ¨ç½²** - é™é»˜å®‰è£…æ”¯æŒï¼Œæ‰¹é‡éƒ¨ç½²è„šæœ¬ï¼Œç»„ç­–ç•¥å…¼å®¹

#### æ„å»ºé…ç½®æ›´æ–°
```json
{
  "bundle": {
    "active": true,
    "targets": ["nsis"],
    "publisher": "å‘ˆå°šç­–åˆ’",
    "category": "Productivity",
    "shortDescription": "å‘ˆå°šç­–åˆ’ä¸“ä¸šå·¥å…·é›†åˆ",
    "longDescription": "é›†æˆ19ä¸ªä¸“ä¸šå·¥å…·çš„æ¡Œé¢åº”ç”¨ï¼ŒæœåŠ¡äºè¿è¥ã€ç¾å·¥ã€é”€å”®ã€äººäº‹ã€å®¢æœç­‰ä¸åŒå²—ä½çš„å·¥ä½œéœ€æ±‚",
    "nsis": {
      "displayLanguageSelector": false,
      "installerIcon": "icons/icon.ico",
      "installMode": "perMachine",
      "allowToChangeInstallationDirectory": true,
      "deleteAppDataOnUninstall": false,
      "shortcutName": "å‘ˆå°šç­–åˆ’å·¥å…·ç®±",
      "publisherName": "å‘ˆå°šç­–åˆ’"
    }
  }
}
```

#### æ ‡å‡†æ„å»ºæµç¨‹
```bash
# 1. æ¸…ç†ä¹‹å‰çš„æ„å»º
cargo clean
rm -rf src-tauri/target/release/bundle

# 2. å®‰è£…/æ›´æ–°ä¾èµ–
pnpm install

# 3. æ‰§è¡Œå®Œæ•´æ„å»º
npm run tauri:build

# 4. éªŒè¯æ„å»ºç»“æœ
ls -la src-tauri/target/release/bundle/nsis/
# è¾“å‡ºï¼šå‘ˆå°šç­–åˆ’é¡¹ç›®å±•ç¤º_1.0.0_x64-setup.exe (20-35MB)
```

#### æ„å»ºäº§ç‰©åˆ†æ
```
src-tauri/target/release/
â”œâ”€â”€ app.exe                                    # ä¸»ç¨‹åº (15-25MB)
â”œâ”€â”€ bundle/
â”‚   â””â”€â”€ nsis/
â”‚       â””â”€â”€ å‘ˆå°šç­–åˆ’é¡¹ç›®å±•ç¤º_1.0.0_x64-setup.exe  # NSISå®‰è£…åŒ… (20-35MB)
â”œâ”€â”€ resources/                                 # åº”ç”¨èµ„æº
â””â”€â”€ deps/                                      # ä¾èµ–åº“æ–‡ä»¶
```

#### è´¨é‡æ£€æŸ¥æ¸…å•
**âœ… æ–‡ä»¶å®Œæ•´æ€§**
- [ ] NSISå®‰è£…åŒ…å·²ç”Ÿæˆ
- [ ] æ–‡ä»¶å¤§å°åœ¨åˆç†èŒƒå›´ (20-35MB)
- [ ] æ–‡ä»¶ååŒ…å«æ­£ç¡®ç‰ˆæœ¬å·
- [ ] å›¾æ ‡æ˜¾ç¤ºæ­£ç¡®

**âœ… å®‰è£…æµ‹è¯•**
- [ ] å®‰è£…ç¨‹åºå¯ä»¥å¯åŠ¨
- [ ] å®‰è£…è¿‡ç¨‹æ— é”™è¯¯
- [ ] è¿›åº¦æ˜¾ç¤ºæ­£å¸¸
- [ ] å®‰è£…è·¯å¾„å¯é€‰æ‹©

**âœ… åŠŸèƒ½æµ‹è¯•**
- [ ] åº”ç”¨å¯ä»¥æ­£å¸¸å¯åŠ¨
- [ ] æ‰€æœ‰19ä¸ªå·¥å…·å¯è®¿é—®
- [ ] WebViewåŠŸèƒ½æ­£å¸¸
- [ ] å¿«æ·æ–¹å¼å·¥ä½œæ­£å¸¸

#### ä¼ä¸šéƒ¨ç½²æ”¯æŒ
```bash
# é™é»˜å®‰è£…å‘½ä»¤
"å‘ˆå°šç­–åˆ’é¡¹ç›®å±•ç¤º_1.0.0_x64-setup.exe" /S

# æŒ‡å®šå®‰è£…è·¯å¾„
"å‘ˆå°šç­–åˆ’é¡¹ç›®å±•ç¤º_1.0.0_x64-setup.exe" /S /D=C:\Program Files\ChengShangCeHua
```

### 3.2 è‡ªåŠ¨æ›´æ–°æœåŠ¡å™¨å®Œæ•´é…ç½®æ–¹æ¡ˆ

é¡¹ç›®å·²å®ç°å®Œæ•´çš„è‡ªåŠ¨æ›´æ–°æœºåˆ¶ï¼Œæ”¯æŒå®‰å…¨çš„åº”ç”¨ç‰ˆæœ¬ç®¡ç†å’Œæ¨é€ï¼š

#### æ›´æ–°æœºåˆ¶æµç¨‹
```mermaid
graph TB
    A[åº”ç”¨å¯åŠ¨] --> B[æ£€æŸ¥æ›´æ–°<br/>å»¶è¿Ÿ3ç§’]
    B --> C{å‘ç°æ–°ç‰ˆæœ¬?}
    C -->|æ˜¯| D[æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†]
    C -->|å¦| E[æ­£å¸¸è¿è¡Œ]
    D --> F[ç”¨æˆ·ç¡®è®¤]
    F --> G[ä¸‹è½½æ›´æ–°åŒ…]
    G --> H[éªŒè¯æ•°å­—ç­¾å]
    H --> I[è‡ªåŠ¨é‡å¯åº”ç”¨]
    I --> J[æ–°ç‰ˆæœ¬ç”Ÿæ•ˆ]
```

#### æ•°å­—ç­¾åå¯†é’¥é…ç½®
```bash
# ç”Ÿæˆç­¾åå¯†é’¥å¯¹
cargo install tauri-cli
tauri signer generate -w ~/.tauri/chengshang.key

# è¾“å‡ºç¤ºä¾‹ï¼š
# Private key: ~/.tauri/chengshang.key
# Public key: dW50cnVzdGVkIGNvbW1lbnQ6IHNpZ25hdHVyZSBmcm9tIHRhdXJpIHNlY3JldCBrZXkK...
```

#### Taurié…ç½®æ›´æ–°
```json
{
  "updater": {
    "active": true,
    "endpoints": [
      "https://api.chengshangcehua.com/releases/{{target}}/{{current_version}}"
    ],
    "dialog": true,
    "pubkey": "dW50cnVzdGVkIGNvbW1lbnQ6IHNpZ25hdHVyZSBmcm9tIHRhdXJpIHNlY3JldCBrZXkK..."
  }
}
```

#### æ›´æ–°æœåŠ¡å™¨APIè§„èŒƒ
```javascript
// å“åº”æ ¼å¼ï¼ˆæœ‰æ›´æ–°æ—¶ï¼‰
{
  "version": "1.1.0",
  "notes": "ä¿®å¤äº†è‹¥å¹²é—®é¢˜ï¼Œæ–°å¢äº†è‡ªåŠ¨æ›´æ–°åŠŸèƒ½",
  "pub_date": "2025-07-29T10:00:00Z",
  "platforms": {
    "windows-x86_64": {
      "signature": "dW50cnVzdGVkIGNvbW1lbnQ6IHNpZ25hdHVyZSBmcm9tIHRhdXJpIHNlY3JldCBrZXkK...",
      "url": "https://api.chengshangcehua.com/releases/v1.1.0/app-setup.exe"
    }
  }
}

// å“åº”æ ¼å¼ï¼ˆæ— æ›´æ–°æ—¶ï¼‰
{
  "version": "1.0.0",
  "notes": "å½“å‰å·²æ˜¯æœ€æ–°ç‰ˆæœ¬",
  "pub_date": "2025-07-29T10:00:00Z"
}
```

#### GitHub Actionsè‡ªåŠ¨åŒ–å‘å¸ƒ
```yaml
# .github/workflows/release.yml
name: Release
on:
  push:
    tags:
      - 'v*'

jobs:
  release:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        
      - name: Install dependencies
        run: pnpm install
        
      - name: Build and release
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
        run: npm run tauri:build
          
      - name: Create Release
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
        with:
          tagName: ${{ github.ref_name }}
          releaseName: 'Release ${{ github.ref_name }}'
          releaseBody: 'See the assets to download and install this version.'
```

#### ç‰ˆæœ¬å‘å¸ƒæµç¨‹
```bash
# 1. æ›´æ–°ç‰ˆæœ¬å·
node scripts/update-version.js 1.1.0

# 2. è®¾ç½®ç§é’¥ç¯å¢ƒå˜é‡
export TAURI_PRIVATE_KEY="$(cat ~/.tauri/chengshang.key)"

# 3. æ„å»ºåº”ç”¨ï¼ˆè‡ªåŠ¨ç­¾åï¼‰
npm run tauri:build

# 4. ä¸Šä¼ åˆ°å‘å¸ƒæœåŠ¡å™¨
scp src-tauri/target/release/bundle/nsis/*.exe user@server:/var/www/releases/
```

#### å®‰å…¨ç­–ç•¥
- âœ… **Ed25519æ•°å­—ç­¾å** - é˜²æ­¢æ¶æ„è½¯ä»¶æ›¿æ¢
- âœ… **HTTPSä¼ è¾“** - é˜²æ­¢ä¸­é—´äººæ”»å‡»
- âœ… **ç‰ˆæœ¬éªŒè¯** - é˜²æ­¢ç‰ˆæœ¬å›æ»šæ”»å‡»
- âœ… **ç­¾åå®Œæ•´æ€§æ£€æŸ¥** - ç¡®ä¿æ›´æ–°åŒ…æœªè¢«ç¯¡æ”¹

### 3.3 å¤šå±‚æ¬¡å¼€å‘è€…å·¥å…·ä¿æŠ¤æœºåˆ¶

ä¸ºä¿æŠ¤åº”ç”¨æºä»£ç å’Œé˜²æ­¢ç”¨æˆ·è¯¯æ“ä½œï¼Œå®ç°äº†ä¼ä¸šçº§çš„å¤šå±‚æ¬¡ä¿æŠ¤ï¼š

#### ä¿æŠ¤å±‚çº§æ¶æ„
```mermaid
graph TB
    A[ç”¨æˆ·æ“ä½œ] --> B[æµè§ˆå™¨äº‹ä»¶å±‚]
    B --> C[JavaScriptæ‹¦æˆª]
    C --> D[CSSæ ·å¼ä¿æŠ¤]
    D --> E[Taurié…ç½®å±‚]
    E --> F[ç³»ç»Ÿçº§ç¦ç”¨]
    
    G[ä¿æŠ¤åŠŸèƒ½] --> H[F12å¼€å‘è€…å·¥å…·]
    G --> I[å³é”®èœå•æ£€æŸ¥]
    G --> J[å¿«æ·é”®æ‹¦æˆª]
    G --> K[æ–‡æœ¬é€‰æ‹©ç¦ç”¨]
    G --> L[é¡µé¢ä¿å­˜é˜»æ­¢]
```

#### å±‚çº§1: Taurié…ç½®å±‚ä¿æŠ¤
```json
{
  "app": {
    "windows": [
      {
        "devtools": false
      }
    ]
  }
}
```

#### å±‚çº§2: JavaScriptäº‹ä»¶æ‹¦æˆª
```typescript
// ç¦ç”¨çš„å¿«æ·é”®ç»„åˆ
const disabledKeys = [
  'F12',                    // å¼€å‘è€…å·¥å…·
  'Ctrl+Shift+I',          // å¼€å‘è€…å·¥å…·
  'Ctrl+Shift+J',          // æ§åˆ¶å°
  'Ctrl+U',                // æŸ¥çœ‹æºä»£ç 
  'Ctrl+Shift+C',          // é€‰æ‹©å…ƒç´ 
  'Ctrl+S',                // ä¿å­˜é¡µé¢
  'Ctrl+A',                // å…¨é€‰
  'Ctrl+P'                 // æ‰“å°
];

// äº‹ä»¶æ‹¦æˆªå®ç°
const disableDevToolsKeys = (e: KeyboardEvent) => {
  if (e.key === 'F12' ||
      (e.ctrlKey && e.shiftKey && e.key === 'I') ||
      (e.ctrlKey && e.shiftKey && e.key === 'J')) {
    e.preventDefault();
    return false;
  }
};

document.addEventListener('keydown', disableDevToolsKeys);
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  return false;
});
```

#### å±‚çº§3: CSSæ ·å¼ä¿æŠ¤
```css
/* ç¦ç”¨æ–‡æœ¬é€‰æ‹© */
* {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* ç¦ç”¨å³é”®èœå• */
body {
  -webkit-context-menu: none;
  -moz-context-menu: none;
  context-menu: none;
}

/* ç¦ç”¨æ‹–æ‹½ */
* {
  -webkit-user-drag: none;
  -moz-user-drag: none;
  user-drag: none;
}
```

#### å¼€å‘è€…å·¥å…·æ£€æµ‹
```typescript
const detectDevTools = () => {
  const threshold = 160;
  setInterval(() => {
    if (
      window.outerHeight - window.innerHeight > threshold ||
      window.outerWidth - window.innerWidth > threshold
    ) {
      console.clear(); // æ¸…ç©ºæ§åˆ¶å°
      // å¯é€‰ï¼šæ˜¾ç¤ºè­¦å‘Šä¿¡æ¯æˆ–é‡‡å–å…¶ä»–ä¿æŠ¤æªæ–½
    }
  }, 500);
};
```

#### ä¿æŠ¤æ•ˆæœæ€»ç»“
**âœ… å·²ç¦ç”¨çš„åŠŸèƒ½**
1. F12é”®æ— æ³•æ‰“å¼€å¼€å‘è€…å·¥å…·
2. å³é”®èœå•æ— æ³•è®¿é—®"æ£€æŸ¥å…ƒç´ "
3. æ‰€æœ‰å¼€å‘è€…å·¥å…·ç›¸å…³å¿«æ·é”®è¢«æ‹¦æˆª
4. æ— æ³•é€‰æ‹©å’Œå¤åˆ¶é¡µé¢æ–‡æœ¬
5. æ— æ³•é€šè¿‡Ctrl+Sä¿å­˜é¡µé¢
6. æ— æ³•é€šè¿‡Ctrl+UæŸ¥çœ‹æºä»£ç 
7. é˜²æ­¢æ‹–æ‹½æ–‡ä»¶åˆ°é¡µé¢

**âš ï¸ ä¾‹å¤–æƒ…å†µ**
- è¾“å…¥æ¡†ä»ç„¶å¯ä»¥é€‰æ‹©å’Œç¼–è¾‘æ–‡æœ¬
- å¼€å‘ç¯å¢ƒä¸‹å¯ä»¥ä¸´æ—¶ç¦ç”¨ä¿æŠ¤æœºåˆ¶

#### å®‰å…¨ç­–ç•¥è¡¥å……å»ºè®®
1. **ä»£ç æ··æ·†** - åœ¨æ„å»ºæ—¶æ··æ·†JavaScriptä»£ç 
2. **æœåŠ¡ç«¯éªŒè¯** - é‡è¦æ“ä½œåœ¨æœåŠ¡ç«¯éªŒè¯
3. **åŠ å¯†é€šä¿¡** - ä½¿ç”¨HTTPSå’Œå…¶ä»–åŠ å¯†æªæ–½
4. **è®¿é—®æ§åˆ¶** - å®ç°ç”¨æˆ·æƒé™ç®¡ç†

**æ³¨æ„**: è¿™äº›ä¿æŠ¤æªæ–½ä¸»è¦é’ˆå¯¹æ™®é€šç”¨æˆ·çš„è¯¯æ“ä½œå’ŒåŸºæœ¬çš„ä»£ç ä¿æŠ¤ï¼Œä¸èƒ½æ›¿ä»£å®Œæ•´çš„å®‰å…¨ç­–ç•¥ã€‚

### 3.1 ç»Ÿä¸€é”™è¯¯å¤„ç†ç³»ç»Ÿ (src-tauri/src/error.rs)
```rust
use thiserror::Error;
use serde::{Deserialize, Serialize};

#[derive(Error, Debug, Serialize, Deserialize)]
pub enum AuthError {
    #[error("Invalid credentials")]
    InvalidCredentials,
    
    #[error("User not found")]
    UserNotFound,
    
    #[error("User is inactive")]
    UserInactive,
    
    #[error("Invalid token")]
    InvalidToken,
    
    #[error("Token generation failed")]
    TokenGenerationFailed,
    
    #[error("Password hashing failed")]
    PasswordHashingFailed,
    
    #[error("Too many login attempts")]
    TooManyLoginAttempts,
    
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Session expired")]
    SessionExpired,
    
    #[error("Insufficient permissions")]
    InsufficientPermissions,
}

#[derive(Error, Debug, Serialize, Deserialize)]
pub enum ApplicationError {
    #[error("Tool not found: {0}")]
    ToolNotFound(String),
    
    #[error("Tool launch failed: {0}")]
    ToolLaunchFailed(String),
    
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    
    #[error("Network error: {0}")]
    NetworkError(String),
    
    #[error("File system error: {0}")]
    FileSystemError(String),
    
    #[error("Database connection failed: {0}")]
    DatabaseConnectionFailed(String),
    
    #[error("WebSocket error: {0}")]
    WebSocketError(String),
    
    #[error("Monitoring error: {0}")]
    MonitoringError(String),
}

#[derive(Error, Debug, Serialize, Deserialize)]
pub enum ValidationError {
    #[error("Invalid input: {field}")]
    InvalidInput { field: String },
    
    #[error("Missing required field: {field}")]
    MissingField { field: String },
    
    #[error("Invalid format: {field}")]
    InvalidFormat { field: String },
    
    #[error("Value out of range: {field}")]
    OutOfRange { field: String },
}

// ç»Ÿä¸€é”™è¯¯å“åº”ç»“æ„
#[derive(Debug, Serialize, Deserialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
    pub code: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub details: Option<serde_json::Value>,
}

impl ErrorResponse {
    pub fn new(error: &str, message: &str, code: &str) -> Self {
        Self {
            error: error.to_string(),
            message: message.to_string(),
            code: code.to_string(),
            timestamp: chrono::Utc::now(),
            details: None,
        }
    }
    
    pub fn with_details(mut self, details: serde_json::Value) -> Self {
        self.details = Some(details);
        self
    }
}

// é”™è¯¯å¤„ç†å·¥å…·å‡½æ•°
pub fn handle_auth_error(error: AuthError) -> ErrorResponse {
    match error {
        AuthError::InvalidCredentials => ErrorResponse::new(
            "INVALID_CREDENTIALS",
            "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯",
            "AUTH_001"
        ),
        AuthError::UserNotFound => ErrorResponse::new(
            "USER_NOT_FOUND",
            "ç”¨æˆ·ä¸å­˜åœ¨",
            "AUTH_002"
        ),
        AuthError::UserInactive => ErrorResponse::new(
            "USER_INACTIVE",
            "ç”¨æˆ·è´¦æˆ·å·²è¢«ç¦ç”¨",
            "AUTH_003"
        ),
        AuthError::InvalidToken => ErrorResponse::new(
            "INVALID_TOKEN",
            "ä»¤ç‰Œæ— æ•ˆæˆ–å·²è¿‡æœŸ",
            "AUTH_004"
        ),
        AuthError::TooManyLoginAttempts => ErrorResponse::new(
            "TOO_MANY_ATTEMPTS",
            "ç™»å½•å°è¯•è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•",
            "AUTH_005"
        ),
        _ => ErrorResponse::new(
            "AUTH_ERROR",
            "è®¤è¯ç³»ç»Ÿé”™è¯¯",
            "AUTH_999"
        ),
    }
}
```

### 3.2 æœåŠ¡ç®¡ç†å®¹å™¨ (src-tauri/src/services/mod.rs)
```rust
pub mod tools;
pub mod admin;
pub mod audit;

use std::sync::Arc;
use crate::database::DatabaseService;
use crate::auth::AuthService;
use crate::config::AppConfig;

pub struct ServiceContainer {
    pub database: Arc<DatabaseService>,
    pub auth: Arc<AuthService>,
    pub config: Arc<AppConfig>,
}

impl ServiceContainer {
    pub fn new(
        database: Arc<DatabaseService>,
        auth: Arc<AuthService>,
        config: Arc<AppConfig>,
    ) -> Self {
        Self {
            database,
            auth,
            config,
        }
    }
}
```

### 3.3 å·¥å…·ç®¡ç†æœåŠ¡ (src-tauri/src/services/tools.rs)
```rust
use crate::database::{DatabaseService, UserActivity, ActivityDetails, ActivityMetadata};
use crate::error::ApplicationError;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use chrono::Utc;
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
pub struct Tool {
    pub id: u32,
    pub name: String,
    pub description: String,
    pub category: String,
    pub url: String,
    pub icon: String,
    pub rating: f32,
    pub downloads: String,
    pub tags: Vec<String>,
    pub color: String,
    pub featured: bool,
    pub last_updated: String,
    pub tool_type: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ToolUsageRequest {
    pub tool_id: u32,
    pub user_id: String,
    pub session_id: String,
    pub device_info: serde_json::Value,
}

pub struct ToolService {
    database: Arc<DatabaseService>,
}

impl ToolService {
    pub fn new(database: Arc<DatabaseService>) -> Self {
        Self { database }
    }

    pub async fn get_all_tools(&self) -> Result<Vec<Tool>, ApplicationError> {
        Ok(self.get_tools_data())
    }

    pub async fn get_tools_by_category(&self, category: &str) -> Result<Vec<Tool>, ApplicationError> {
        let all_tools = self.get_all_tools().await?;
        let filtered_tools: Vec<Tool> = all_tools
            .into_iter()
            .filter(|tool| tool.category == category)
            .collect();
        Ok(filtered_tools)
    }

    pub async fn launch_tool(&self, tool_id: u32, user_id: &str) -> Result<String, ApplicationError> {
        let tools = self.get_all_tools().await?;
        let tool = tools
            .iter()
            .find(|t| t.id == tool_id)
            .ok_or_else(|| ApplicationError::ToolNotFound(tool_id.to_string()))?;

        // è®°å½•å·¥å…·ä½¿ç”¨æ´»åŠ¨
        self.log_tool_usage(tool, user_id, true, None).await?;

        // æ ¹æ®å·¥å…·ç±»å‹æ‰§è¡Œä¸åŒçš„å¯åŠ¨é€»è¾‘
        match tool.tool_type.as_str() {
            "web" => {
                self.launch_web_tool(&tool.url).await
            }
            "desktop" => {
                self.launch_desktop_tool(tool).await
            }
            "integrated" => {
                self.launch_integrated_tool(tool).await
            }
            _ => Err(ApplicationError::ToolLaunchFailed(
                "Unsupported tool type".to_string()
            ))
        }
    }

    async fn launch_web_tool(&self, url: &str) -> Result<String, ApplicationError> {
        use tauri::api::shell;
        
        shell::open(&Default::default(), url, None)
            .map_err(|e| ApplicationError::ToolLaunchFailed(e.to_string()))?;
        
        Ok(format!("Web tool launched: {}", url))
    }

    async fn launch_desktop_tool(&self, tool: &Tool) -> Result<String, ApplicationError> {
        match tool.name.as_str() {
            "å¾®ä¿¡ç¾¤å‘åŠ©æ‰‹" => {
                self.launch_wechat_helper().await
            }
            _ => Err(ApplicationError::ToolLaunchFailed(
                "Desktop tool not implemented".to_string()
            ))
        }
    }

    async fn launch_integrated_tool(&self, tool: &Tool) -> Result<String, ApplicationError> {
        Ok(format!("Integrated tool launched: {}", tool.name))
    }

    async fn launch_wechat_helper(&self) -> Result<String, ApplicationError> {
        Ok("WeChat helper launched successfully".to_string())
    }

    async fn log_tool_usage(
        &self,
        tool: &Tool,
        user_id: &str,
        success: bool,
        error_message: Option<String>,
    ) -> Result<(), ApplicationError> {
        use mongodb::bson::oid::ObjectId;

        let user_object_id = ObjectId::parse_str(user_id)
            .map_err(|e| ApplicationError::DatabaseConnectionFailed(e.to_string()))?;

        let activity = UserActivity {
            id: None,
            user_id: user_object_id,
            activity_type: "tool_access".to_string(),
            tool_id: Some(tool.id),
            details: ActivityDetails {
                tool_name: Some(tool.name.clone()),
                duration: None,
                success,
                error_message,
            },
            metadata: ActivityMetadata {
                ip_address: "127.0.0.1".to_string(),
                user_agent: "Tauri Application".to_string(),
                session_id: Uuid::new_v4().to_string(),
            },
            timestamp: Utc::now(),
        };

        self.database.log_user_activity(activity).await
            .map_err(|e| ApplicationError::DatabaseConnectionFailed(e.to_string()))?;

        Ok(())
    }

    fn get_tools_data(&self) -> Vec<Tool> {
        // è¿”å›19ä¸ªå·¥å…·çš„å®Œæ•´æ•°æ®
        vec![
            Tool {
                id: 1,
                name: "å•†å®¶å›å¤è§£ç­”æ‰‹å†Œ".to_string(),
                description: "æä¾›æ ‡å‡†åŒ–çš„å®¢æˆ·åé¦ˆå¤„ç†æ¨¡æ¿å’Œæ²Ÿé€šæŠ€å·§".to_string(),
                category: "è¿è¥å·¥å…·".to_string(),
                url: "https://xuxikai886.github.io/shangjiahuizong/".to_string(),
                icon: "MessageSquare".to_string(),
                rating: 4.8,
                downloads: "2.1k".to_string(),
                tags: vec!["å›å¤æ¨¡æ¿".to_string(), "æ²Ÿé€šæŠ€å·§".to_string(), "å®¢æˆ·åé¦ˆ".to_string()],
                color: "from-blue-500 to-blue-600".to_string(),
                featured: true,
                last_updated: "2å¤©å‰".to_string(),
                tool_type: "web".to_string(),
            },
            // ... å…¶ä»–18ä¸ªå·¥å…·çš„æ•°æ®
            Tool {
                id: 19,
                name: "å¤–å–åº—é“ºä¿¡æ¯é‡‡é›†ç³»ç»Ÿ".to_string(),
                description: "æ‰¹é‡é‡‡é›†å¤–å–åº—é“ºåŸºç¡€ä¿¡æ¯".to_string(),
                category: "å®¢æœå·¥å…·".to_string(),
                url: "https://xuxikai886.github.io/meituandianpuxinxicaiji/".to_string(),
                icon: "Search".to_string(),
                rating: 4.9,
                downloads: "3.2k".to_string(),
                tags: vec!["è‡ªåŠ¨è§£æ".to_string(), "æ‰¹é‡å¤„ç†".to_string(), "Excelå¯¼å‡º".to_string()],
                color: "from-pink-500 to-pink-600".to_string(),
                featured: true,
                last_updated: "1å¤©å‰".to_string(),
                tool_type: "web".to_string(),
            },
        ]
    }
}

// Tauriå‘½ä»¤å®ç°
#[tauri::command]
pub async fn get_tools(
    state: tauri::State<'_, crate::AppState>,
) -> Result<Vec<Tool>, String> {
    let tool_service = ToolService::new(state.db.clone());
    tool_service.get_all_tools().await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn launch_tool(
    state: tauri::State<'_, crate::AppState>,
    tool_id: u32,
    user_id: String,
) -> Result<String, String> {
    let tool_service = ToolService::new(state.db.clone());
    tool_service.launch_tool(tool_id, &user_id).await
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn track_usage(
    state: tauri::State<'_, crate::AppState>,
    request: ToolUsageRequest,
) -> Result<(), String> {
    // è®°å½•ä½¿ç”¨ç»Ÿè®¡
    Ok(())
}
```

### 3.4 å®‰å…¨ç­–ç•¥ä¸å®¡è®¡æ—¥å¿— (src-tauri/src/services/audit.rs)
```rust
use crate::database::DatabaseService;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use chrono::Utc;
use mongodb::bson::oid::ObjectId;

#[derive(Debug, Serialize, Deserialize)]
pub struct AuditLog {
    #[serde(rename = "_id", skip_serializing_if = "Option::is_none")]
    pub id: Option<ObjectId>,
    pub user_id: ObjectId,
    pub action: String,
    pub resource: String,
    pub resource_id: String,
    pub old_values: Option<serde_json::Value>,
    pub new_values: Option<serde_json::Value>,
    pub ip_address: String,
    pub user_agent: String,
    pub success: bool,
    pub error_message: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct SecurityEvent {
    pub event_type: String,
    pub severity: String, // LOW, MEDIUM, HIGH, CRITICAL
    pub description: String,
    pub user_id: Option<String>,
    pub ip_address: String,
    pub user_agent: String,
    pub metadata: serde_json::Value,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

pub struct AuditService {
    database: Arc<DatabaseService>,
}

impl AuditService {
    pub fn new(database: Arc<DatabaseService>) -> Self {
        Self { database }
    }

    pub async fn log_audit_event(
        &self,
        user_id: ObjectId,
        action: &str,
        resource: &str,
        resource_id: &str,
        old_values: Option<serde_json::Value>,
        new_values: Option<serde_json::Value>,
        ip_address: &str,
        user_agent: &str,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let audit_log = AuditLog {
            id: None,
            user_id,
            action: action.to_string(),
            resource: resource.to_string(),
            resource_id: resource_id.to_string(),
            old_values,
            new_values,
            ip_address: ip_address.to_string(),
            user_agent: user_agent.to_string(),
            success: true,
            error_message: None,
            timestamp: Utc::now(),
        };

        // è¿™é‡Œéœ€è¦åœ¨DatabaseServiceä¸­å®ç°save_audit_logæ–¹æ³•
        // self.database.save_audit_log(audit_log).await?;
        
        Ok(())
    }

    pub async fn log_security_event(&self, event: SecurityEvent) -> Result<(), Box<dyn std::error::Error>> {
        tracing::warn!(
            "Security event: {} - {} - {:?}", 
            event.event_type, 
            event.severity, 
            event.description
        );
        
        Ok(())
    }

    pub async fn check_suspicious_activity(&self, user_id: &str, ip_address: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // å®ç°å¯ç–‘æ´»åŠ¨æ£€æµ‹é€»è¾‘
        Ok(false)
    }

    pub async fn get_user_audit_trail(
        &self, 
        user_id: &str, 
        from_date: chrono::DateTime<chrono::Utc>,
        to_date: chrono::DateTime<chrono::Utc>
    ) -> Result<Vec<AuditLog>, Box<dyn std::error::Error>> {
        Ok(vec![])
    }
}

// å®‰å…¨ç­–ç•¥é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityPolicy {
    pub password_policy: PasswordPolicy,
    pub session_policy: SessionPolicy,
    pub access_policy: AccessPolicy,
    pub audit_policy: AuditPolicy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PasswordPolicy {
    pub min_length: u32,
    pub require_uppercase: bool,
    pub require_lowercase: bool,
    pub require_numbers: bool,
    pub require_special_chars: bool,
    pub password_history: u32,
    pub max_age_days: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SessionPolicy {
    pub max_concurrent_sessions: u32,
    pub idle_timeout_minutes: u32,
    pub absolute_timeout_hours: u32,
    pub require_reauth_for_sensitive_ops: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessPolicy {
    pub max_login_attempts: u32,
    pub lockout_duration_minutes: u32,
    pub ip_whitelist: Vec<String>,
    pub ip_blacklist: Vec<String>,
    pub geo_restrictions: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditPolicy {
    pub log_all_user_actions: bool,
    pub log_system_events: bool,
    pub log_security_events: bool,
    pub retention_days: u32,
    pub real_time_alerts: bool,
}

impl Default for SecurityPolicy {
    fn default() -> Self {
        Self {
            password_policy: PasswordPolicy {
                min_length: 8,
                require_uppercase: true,
                require_lowercase: true,
                require_numbers: true,
                require_special_chars: true,
                password_history: 5,
                max_age_days: 90,
            },
            session_policy: SessionPolicy {
                max_concurrent_sessions: 3,
                idle_timeout_minutes: 60,
                absolute_timeout_hours: 8,
                require_reauth_for_sensitive_ops: true,
            },
            access_policy: AccessPolicy {
                max_login_attempts: 5,
                lockout_duration_minutes: 15,
                ip_whitelist: vec![],
                ip_blacklist: vec![],
                geo_restrictions: vec![],
            },
            audit_policy: AuditPolicy {
                log_all_user_actions: true,
                log_system_events: true,
                log_security_events: true,
                retention_days: 365,
                real_time_alerts: true,
            },
        }
    }
}
```

### 3.5 ç”Ÿäº§ç¯å¢ƒé…ç½® (src-tauri/tauri.conf.json)
```json
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devPath": "http://localhost:3000",
    "distDir": "../out"
  },
  "package": {
    "productName": "å‘ˆå°šç­–åˆ’å·¥å…·ç®±",
    "version": "2.0.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "all": false,
        "open": true
      },
      "window": {
        "all": false,
        "close": true,
        "hide": true,
        "show": true,
        "maximize": true,
        "minimize": true,
        "unmaximize": true,
        "unminimize": true,
        "startDragging": true
      },
      "fs": {
        "all": false,
        "readFile": true,
        "writeFile": true,
        "readDir": true,
        "createDir": true,
        "removeDir": false,
        "removeFile": false,
        "scope": ["$APPDATA/chengshang-tools/*"]
      },
      "http": {
        "all": false,
        "request": true,
        "scope": [
          "https://api.chengshangcehua.com/*",
          "wss://api.chengshangcehua.com/*"
        ]
      }
    },
    "bundle": {
      "active": true,
      "targets": "all",
      "identifier": "com.chengshang.tools",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "resources": [],
      "externalBin": [],
      "copyright": "Â© 2024 å‘ˆå°šç­–åˆ’",
      "category": "Business",
      "shortDescription": "ä¸“ä¸šçš„æ¡Œé¢å·¥å…·ç®±åº”ç”¨",
      "longDescription": "é›†æˆ19ä¸ªä¸“ä¸šå·¥å…·çš„æ¡Œé¢åº”ç”¨ï¼Œæä¾›è¿è¥ã€ç¾å·¥ã€é”€å”®ã€äººäº‹ã€å®¢æœç­‰å¤šå²—ä½å·¥ä½œæ”¯æŒ"
    },
    "security": {
      "csp": "default-src 'self'; connect-src 'self' https: wss:; img-src 'self' data: https:; style-src 'self' 'unsafe-inline';"
    },
    "windows": [
      {
        "fullscreen": false,
        "height": 800,
        "resizable": true,
        "title": "å‘ˆå°šç­–åˆ’å·¥å…·ç®±",
        "width": 1200,
        "minWidth": 1000,
        "minHeight": 700,
        "center": true,
        "decorations": true,
        "alwaysOnTop": false,
        "skipTaskbar": false
      }
    ],
    "systemTray": {
      "iconPath": "icons/icon.png",
      "iconAsTemplate": true,
      "menuOnLeftClick": false
    },
    "updater": {
      "active": true,
      "endpoints": [
        "https://api.chengshangcehua.com/updates/{{target}}/{{arch}}/{{current_version}}"
      ],
      "dialog": true,
      "pubkey": "dW50cnVzdGVkIGNvbW1lbnQ6IG1pbmlzaWduIHB1YmxpYyBrZXk6IDhCOEVCQzE5NEY4QkE4MjcKUldTZGhhZjRrKzR6Y2FzQkNyZTJPYklXclJ5dDRqa21TZUpMZlN0MGJCbmhLOGNldGhRZnBLU3cK"
    }
  }
}
```

### 3.6 Docker éƒ¨ç½²é…ç½® (Dockerfile)
```dockerfile
# æ„å»ºé˜¶æ®µ
FROM node:18-alpine AS frontend-builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

# Rustæ„å»ºé˜¶æ®µ
FROM rust:1.75-alpine AS backend-builder

RUN apk add --no-cache musl-dev

WORKDIR /app
COPY src-tauri/Cargo.toml src-tauri/Cargo.lock ./
COPY src-tauri/src ./src

RUN cargo build --release

# ç”Ÿäº§é˜¶æ®µ
FROM alpine:latest

RUN apk add --no-cache ca-certificates

WORKDIR /app

# å¤åˆ¶æ„å»ºç»“æœ
COPY --from=frontend-builder /app/out ./web
COPY --from=backend-builder /app/target/release/chengshang-tools ./

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup

USER appuser

EXPOSE 8080

CMD ["./chengshang-tools"]
```

### 3.7 éƒ¨ç½²è„šæœ¬ (deploy.sh)
```bash
#!/bin/bash

# å‘ˆå°šç­–åˆ’å·¥å…·ç®±éƒ¨ç½²è„šæœ¬

set -e

# é…ç½®å˜é‡
APP_NAME="chengshang-tools"
VERSION="2.0.0"
DEPLOY_DIR="/opt/chengshang-tools"
SERVICE_USER="chengshang"
MONGODB_URL=${MONGODB_URL:-"mongodb://localhost:27017/chengshang_tools"}
JWT_SECRET=${JWT_SECRET:-"change-this-in-production"}

echo "ğŸš€ å¼€å§‹éƒ¨ç½²å‘ˆå°šç­–åˆ’å·¥å…·ç®± v${VERSION}"

# æ£€æŸ¥ä¾èµ–
command -v docker >/dev/null 2>&1 || { echo "âŒ Docker æœªå®‰è£…"; exit 1; }
command -v docker-compose >/dev/null 2>&1 || { echo "âŒ Docker Compose æœªå®‰è£…"; exit 1; }

# åˆ›å»ºéƒ¨ç½²ç›®å½•
sudo mkdir -p ${DEPLOY_DIR}
sudo chown ${SERVICE_USER}:${SERVICE_USER} ${DEPLOY_DIR}

# å¤åˆ¶é…ç½®æ–‡ä»¶
cat > ${DEPLOY_DIR}/docker-compose.yml << EOF
version: '3.8'

services:
  app:
    image: chengshang/tools:${VERSION}
    container_name: ${APP_NAME}
    restart: unless-stopped
    environment:
      - DATABASE_URL=${MONGODB_URL}
      - JWT_SECRET=${JWT_SECRET}
      - RUST_LOG=info
    ports:
      - "8080:8080"
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - mongodb
    networks:
      - chengshang-network

  mongodb:
    image: mongo:7
    container_name: chengshang-mongodb
    restart: unless-stopped
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=password123
      - MONGO_INITDB_DATABASE=chengshang_tools
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
      - ./mongodb-init:/docker-entrypoint-initdb.d
    networks:
      - chengshang-network

  nginx:
    image: nginx:alpine
    container_name: chengshang-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    networks:
      - chengshang-network

volumes:
  mongodb_data:

networks:
  chengshang-network:
    driver: bridge
EOF

# åˆ›å»ºNginxé…ç½®
cat > ${DEPLOY_DIR}/nginx.conf << EOF
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:8080;
    }

    server {
        listen 80;
        server_name _;
        
        location / {
            proxy_pass http://app;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
        
        location /ws {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }
    }
}
EOF

# å¯åŠ¨æœåŠ¡
cd ${DEPLOY_DIR}
docker-compose up -d

echo "âœ… éƒ¨ç½²å®Œæˆ!"
echo "ğŸ“Š åº”ç”¨è®¿é—®åœ°å€: http://localhost"
echo "ğŸ—„ï¸  MongoDBè®¿é—®åœ°å€: mongodb://localhost:27017"
echo "ğŸ“œ æŸ¥çœ‹æ—¥å¿—: docker-compose logs -f"
echo "ğŸ”§ ç®¡ç†æœåŠ¡: docker-compose [start|stop|restart]"
```

### 3.8 æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

#### å‰ç«¯æ€§èƒ½ä¼˜åŒ–
- **ä»£ç åˆ†å‰²**: ä½¿ç”¨Next.jsçš„åŠ¨æ€å¯¼å…¥å®ç°ç»„ä»¶æ‡’åŠ è½½
- **èµ„æºä¼˜åŒ–**: å›¾ç‰‡å‹ç¼©ã€CSS Tree Shakingã€JavaScriptæ··æ·†
- **ç¼“å­˜ç­–ç•¥**: åˆç†è®¾ç½®HTTPç¼“å­˜å¤´ï¼Œä½¿ç”¨Service Worker
- **æ¸²æŸ“ä¼˜åŒ–**: è™šæ‹Ÿåˆ—è¡¨ã€é˜²æŠ–èŠ‚æµã€React.memoä¼˜åŒ–

#### åç«¯æ€§èƒ½ä¼˜åŒ–
- **æ•°æ®åº“ä¼˜åŒ–**: åˆç†çš„ç´¢å¼•è®¾è®¡ã€æŸ¥è¯¢ä¼˜åŒ–ã€è¿æ¥æ± ç®¡ç†
- **å†…å­˜ç®¡ç†**: Rusté›¶æˆæœ¬æŠ½è±¡ã€æ™ºèƒ½æŒ‡é’ˆä½¿ç”¨ã€å†…å­˜æ³„æ¼æ£€æµ‹
- **å¹¶å‘å¤„ç†**: Tokioå¼‚æ­¥è¿è¡Œæ—¶ã€è¿æ¥å¤ç”¨ã€ä»»åŠ¡è°ƒåº¦ä¼˜åŒ–
- **ç¼“å­˜æœºåˆ¶**: Redisç¼“å­˜çƒ­ç‚¹æ•°æ®ã€CDNé™æ€èµ„æºåˆ†å‘

### 3.9 æµ‹è¯•ç­–ç•¥å®ç°

#### å•å…ƒæµ‹è¯•æ¡†æ¶
```rust
// src-tauri/tests/auth_test.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_password_hashing() {
        let password = "test_password_123";
        let hash = AuthService::hash_password(password).unwrap();
        
        assert_ne!(hash, password);
        assert!(hash.starts_with("$argon2"));
    }

    #[tokio::test]
    async fn test_jwt_token_generation() {
        // æµ‹è¯•JWTä»¤ç‰Œç”Ÿæˆå’ŒéªŒè¯
    }

    #[tokio::test]
    async fn test_login_rate_limiting() {
        // æµ‹è¯•ç™»å½•é¢‘ç‡é™åˆ¶
    }
}
```

#### é›†æˆæµ‹è¯•
```typescript
// tests/integration/auth.test.ts
import { invoke } from '@tauri-apps/api/tauri'

describe('Authentication Integration Tests', () => {
  test('should login with valid credentials', async () => {
    const loginRequest = {
      username: 'testuser',
      password: 'testpass123',
      device_info: {
        user_agent: 'test-agent',
        ip_address: '127.0.0.1',
        device_type: 'desktop'
      }
    }

    const response = await invoke('login', { request: loginRequest })
    
    expect(response).toHaveProperty('access_token')
    expect(response).toHaveProperty('refresh_token')
    expect(response).toHaveProperty('user')
  })
})
```

### 3.10 ç›‘æ§ä¸å‘Šè­¦ç³»ç»Ÿ

#### ç³»ç»Ÿç›‘æ§æŒ‡æ ‡
- **æ€§èƒ½æŒ‡æ ‡**: CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œä½¿ç”¨ç‡
- **åº”ç”¨æŒ‡æ ‡**: å“åº”æ—¶é—´ã€é”™è¯¯ç‡ã€å¹¶å‘ç”¨æˆ·æ•°ã€å·¥å…·ä½¿ç”¨ç»Ÿè®¡
- **ä¸šåŠ¡æŒ‡æ ‡**: ç”¨æˆ·æ´»è·ƒåº¦ã€åŠŸèƒ½ä½¿ç”¨é¢‘ç‡ã€é”™è¯¯ç±»å‹åˆ†å¸ƒ

#### å‘Šè­¦è§„åˆ™é…ç½®
```rust
pub struct AlertRule {
    pub name: String,
    pub condition: AlertCondition,
    pub threshold: f64,
    pub duration: Duration,
    pub severity: AlertSeverity,
    pub enabled: bool,
}

pub enum AlertSeverity {
    Info,
    Warning,
    Critical,
}

impl AlertRule {
    pub fn cpu_high_usage() -> Self {
        Self {
            name: "CPUä½¿ç”¨ç‡è¿‡é«˜".to_string(),
            condition: AlertCondition::GreaterThan,
            threshold: 80.0,
            duration: Duration::from_mins(5),
            severity: AlertSeverity::Warning,
            enabled: true,
        }
    }
}
```

## ğŸ“ˆ é¡¹ç›®é‡Œç¨‹ç¢‘ä¸å¼€å‘æ—¶é—´è¡¨

### Phase 1: åŸºç¡€æ¶æ„é‡æ„ (4å‘¨)
- **ç¬¬1å‘¨**: æ•°æ®åº“è®¾è®¡ä¸MongoDBé›†æˆ
- **ç¬¬2å‘¨**: JWTè®¤è¯ç³»ç»Ÿå®ç°
- **ç¬¬3å‘¨**: Ruståç«¯æœåŠ¡æ¶æ„æ­å»º
- **ç¬¬4å‘¨**: åŸºç¡€APIæ¥å£å¼€å‘ä¸æµ‹è¯•

### Phase 2: å‰ç«¯å¼€å‘ä¸é›†æˆ (3å‘¨)
- **ç¬¬5å‘¨**: Reactç»„ä»¶é‡æ„ä¸ç™»å½•ç•Œé¢
- **ç¬¬6å‘¨**: ç®¡ç†åå°ä»ªè¡¨æ¿å¼€å‘
- **ç¬¬7å‘¨**: WebSocketå®æ—¶é€šä¿¡é›†æˆ

### Phase 3: ç³»ç»Ÿç›‘æ§ä¸éƒ¨ç½² (3å‘¨)
- **ç¬¬8å‘¨**: ç³»ç»Ÿç›‘æ§æœåŠ¡å®ç°
- **ç¬¬9å‘¨**: å®‰å…¨ç­–ç•¥ä¸å®¡è®¡æ—¥å¿—
- **ç¬¬10å‘¨**: éƒ¨ç½²é…ç½®ä¸ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–

### Phase 4: æµ‹è¯•ä¸å‘å¸ƒ (2å‘¨)
- **ç¬¬11å‘¨**: å®Œæ•´åŠŸèƒ½æµ‹è¯•ä¸æ€§èƒ½ä¼˜åŒ–
- **ç¬¬12å‘¨**: ç”¨æˆ·éªŒæ”¶æµ‹è¯•ä¸æ­£å¼å‘å¸ƒ

## ğŸ¯ å‡çº§ç‰ˆæœ¬æˆåŠŸæ ‡å‡†

### æŠ€æœ¯æŒ‡æ ‡
1. **æ€§èƒ½è¡¨ç°**: ç™»å½•å“åº”æ—¶é—´<2ç§’ï¼Œå·¥å…·å¯åŠ¨æ—¶é—´<3ç§’
2. **ç³»ç»Ÿç¨³å®šæ€§**: 7Ã—24å°æ—¶ç¨³å®šè¿è¡Œï¼Œæ•…éšœç‡<0.1%
3. **å®‰å…¨æ€§**: é€šè¿‡å®‰å…¨æ¼æ´æ‰«æï¼Œç¬¦åˆä¼ä¸šå®‰å…¨æ ‡å‡†
4. **æ‰©å±•æ€§**: æ”¯æŒ100+å¹¶å‘ç”¨æˆ·ï¼Œæ•°æ®åº“å¯å­˜å‚¨ç™¾ä¸‡çº§è®°å½•

### ä¸šåŠ¡æŒ‡æ ‡
1. **ç”¨æˆ·ä½“éªŒ**: ç”¨æˆ·æ»¡æ„åº¦è¯„åˆ†>9.0/10
2. **åŠŸèƒ½å®Œæ•´æ€§**: 19ä¸ªå·¥å…·å…¨éƒ¨æ­£å¸¸è¿è¡Œï¼Œæ–°å¢è®¤è¯ç®¡ç†åŠŸèƒ½
3. **ç®¡ç†æ•ˆç‡**: ç®¡ç†å‘˜æ“ä½œæ•ˆç‡æå‡80%ï¼Œå®æ—¶ç›‘æ§è¦†ç›–ç‡100%
4. **æ•°æ®æ´å¯Ÿ**: æä¾›å®Œæ•´çš„ç”¨æˆ·è¡Œä¸ºåˆ†æå’Œç³»ç»Ÿæ€§èƒ½æŠ¥å‘Š

æœ¬æ–‡æ¡£å°†ä½œä¸ºæ•´ä¸ªé¡¹ç›®å¼€å‘çš„æŒ‡å¯¼æ–‡ä»¶ï¼Œç¡®ä¿å¼€å‘å›¢é˜Ÿèƒ½å¤ŸæŒ‰ç…§ç»Ÿä¸€çš„æ ‡å‡†å’Œæµç¨‹å®Œæˆé«˜è´¨é‡çš„æ¡Œé¢åº”ç”¨å¼€å‘ã€‚